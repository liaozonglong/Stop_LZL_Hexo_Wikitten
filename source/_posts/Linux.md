---
title: Linux
urlname: gymgpc
date: '2021-08-12 12:15:52 +0800'
<br />title: Linux
tags:
  - Linux
categories:
  - 计算机
  - 系统
  - Linux
---

​

## 第一章 Linux 是什么

由于不同的硬件他的功能函数并不相同，例如 IBM 的 Power CPU 与 Intel 的 x86 架构就是不一样！所以同一套操作系统是无法在不同的硬件平台上面运作的！举例来说，如果你想要让 x86 上面跑的）操作系统也能够在 Power CPU 上运作时，就得要将该操作系统进行修改才行。如果能够参考硬件的能函数并据以修改你的操作系统程序代码，那经过改版后的操作系统就能够在另一个硬件作了。这个动作我们通常就称为“软件移植”！
​

## 第三章 主机规划与磁盘分区

那么是否每个扇区都一样重要呢？其实整颗磁盘的第一个扇区特别的重要，因为他记录了整颗磁盘的重要信息！ 磁盘的第一个扇区主要记录了两个重要的信息，分别是：

- 主要启动记录区(Master Boot Record, MBR)：可以安装开机管理程序的地方，有 446 bytes 分割表（partition table）：记录整颗硬盘分割的状态，有 64 bytes
- MBR 是很重要的，因为当系统在开机的时候会主动去读取这个区块的内容，这样系统才会知道你的程序放在哪里且该如何进行开机。 如果你要安装多重引导的系统，MBR 这个区块的管理就非常非常的重要了！

​

在计算器概论里面我们有谈到那个可爱的 BIOS 与 CMOS 两个东西，CMOS 是记录各项硬件参数且嵌入在主板上面的储存器，BIOS 则是一个写入到主板上的一个韧体(再次说明， 韧体就是写入到硬件上的一个软件程序)。这个 BIOS 就是在开机的时候，计算机系统会主动执行的第一个程序了！接下来 BIOS 会去分析计算机里面有哪些储存设备，我们以硬盘为例，BIOS 会依据使用者的设定去取得能够开机的硬盘，并且到该硬盘里面去读取第一个扇区的 MBR 位置。MBR 这个仅有 446 bytes 的硬盘容量里面会放置最基本的开机管理程序，此时 BIOS 就功成圆满，而接下来就是 MBR 内的开机管理程序的工作了。
这个开机管理程序的目的是在加载(load)核心档案，由于开机管理程序是操作系统在安装的时候所提供的，所以他会认识硬盘内的文件系统格式，因此就能够读取核心档案，然后接下来就是核心档案的工作，开机管理程序也功成圆满，之后就是大家所知道的操作系统的任务啦！

简单的说，整个开机流程到操作系统之前的动作应该是这样的：

1. BIOS：开机主动执行的韧体，会认识第一个可开机的装置；
1. MBR：第一个可开机装置的第一个扇区内的主要启动记录区块，内含开机管理程序；
1. 开机管理程序(boot loader)：一支可读取核心档案来执行的软件；
1. 核心档案：开始操作系统的功能...
   由上面的说明我们会知道，BIOS 与 MBR 都是硬件本身会支持的功能，至于 Boot loader 则是操作系统安装在 MBR 上面的一套软件了。由于 MBR 仅有 446 bytes 而已，因此这个开机管理程序是非常小而美的。这个 boot loader 的主要任务有底下这些项目：
   提供选单：用户可以选择不同的开机项目，这也是多重引导的重要功能！
   载入核心档案：直接指向可开机的程序区段来开始操作系统；
   转交其他 loader：将开机管理功能转交给其他 loader 负责。

​

​

![](https://i.loli.net/2021/11/29/ThLG65gt9vFm8jK.png#id=sE12M&originHeight=299&originWidth=456&originalType=binary∶=1&status=done&style=none#crop=0&crop=0&crop=1&crop=1&id=BVsGH&originHeight=299&originWidth=456&originalType=binary∶=1&rotation=0&showTitle=false&status=done&style=none&title=)
在上图中我们可以发现，MBR 的开机管理程序提供两个选单，选单一(M1)可以直接加载 Windows 的核心档案来开机；选单二(M2)则是将开机管理工作交给第二个分割槽的启动扇区(boot sector)。当使用者在开机的时候选择选单二时，那么整个开机管理工作就会交给第二分割槽的开机管理程序了。 当第二个开机管理程序启动后，该开机管理程序内(上图中)仅有一个开机选单，因此就能够使用 Linux 的
核心档案来开机啰。这就是多重引导的工作情况啦！我们将上图作个总结：

- 每个分割槽都拥有自己的启动扇区(boot sector)
- 图中的系统槽为第一及第二分割槽，
- 实际可开机的核心档案是放置到各分割槽内的！
- loader 只会认识自己的系统槽内的可开机核心档案，以及其他 loader 而已 ;
- loader 可直接指向或者是间接将管理权转交给另一个管理程序。

那现在请你想一想，为什么人家常常说：『如果要安装多重引导，最好先安装 Windows 再安装
Linux」呢？这是因为：Linux 在安装的时候，你可以选择将开机管理程序安装在 MBR 或各别分割槽的启动扇区，而且 Linux 的 loader 可以手动设定选单(就是上图的 M1,M2...)，所以你可以在 Linux 的 bootloader 里面加入 Windows 开机的选项；Windows 那你在安装的时候，他的安装程序会主动的覆盖掉 MBR 以及自己所在分割槽的启动扇区，你没有选择的机会，而且他没有让我们自己选择选单的功能。
​

![](https://i.loli.net/2021/11/30/etdxWKPgvQ19wFT.png#id=aqzmG&originHeight=191&originWidth=360&originalType=binary∶=1&status=done&style=none#crop=0&crop=0&crop=1&crop=1&id=jyZyG&originHeight=191&originWidth=360&originalType=binary∶=1&rotation=0&showTitle=false&status=done&style=none&title=)
如上图所示，所有的档案都是由根目录(/)衍生来的，而次目录之下还能够有其他的数据存在。上图中长方形为目录，波浪形则为档案。那当我们想要取得 mydata 那个档案时，系统就得由根目录开始找，然后找到 home 接下来找到 dmtsai，最终的档名为：/home/dmtsai/mydata 的意思。
​

![](https://i.loli.net/2021/11/30/YI4fbqhtejWvzdn.png#id=DkpqC&originHeight=240&originWidth=492&originalType=binary∶=1&status=done&style=none#crop=0&crop=0&crop=1&crop=1&id=qGv5B&originHeight=240&originWidth=492&originalType=binary∶=1&rotation=0&showTitle=false&status=done&style=none&title=)
所谓的『挂载』就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下； 也就是说，进入该目录就可以读取该分割槽的意思。这个动作我们称为『挂载』，那个进入点的目录我们称为『挂载点』。 由于整个 Linux 系统最重要的是根目录，因此根目录一定需要挂载到某个分割槽的。 至于其他的目录则可依用户自己的需求来给予挂载到不同的分割槽。我们以上图来作为一个说明：
​

## 第四章、安装 CentOS 5.x 与多重引导小技巧

那如果按下的是[F5]时，就会进入到救援模式的说明画面，如下图所示：
![](https://i.loli.net/2021/12/02/YP8iNljTpWAGwdo.png#id=jPUvN&originHeight=210&originWidth=424&originalType=binary∶=1&status=done&style=none#crop=0&crop=0&crop=1&crop=1&id=QadGy&originHeight=210&originWidth=424&originalType=binary∶=1&rotation=0&showTitle=false&status=done&style=none&title=)

### 内存压力测试：memtest86

CentOS 的 DVD 除了提供一般 PC 来安装 Linux 之外，还提供了不少有趣的东西，其中一个就是进行
『烧机』的任务！ 这个烧机不是台湾名产烧酒鸡啊，而是当你组装了一部新的个人计算机，想要测试这部主机是否稳定时，就在这部主机上面运作一些比较耗系统资源的程序，让系统在高负载的情下去运作一阵子(可能是一天)，去测试稳定度的一种情况，就称为『烧机』啦！
​

### Kdump 与时区的校正

完成了防火墙与 SELinux 的选择后，接下来会出现如下的 Kdump 窗口。什么是 Kdump 呢？这个 Kdump 就是，当核心出现错误的时候，是否要将当时的内存内的讯息写到档案中，而这个档案就能够给核心开发者研究为啥会当机之用。 我们并不是核心开发者，而且内存内的数据实在太大了，因此常常进行 Kdump 会造成硬盘空间的浪费。 所以，这里建议不要启动 Kdump 的功能喔！
​

## 第五章、首次登入与在线求助 man page

### 重新启动 X Window 的快速按钮

般来说，我们是可以手动来直接修改 X Window 的配置文件的，不过，修改完成之后的设定项目并不会立刻被加载，必须要重新启动 Ⅹ 才行(特别注意，不是重新启动，而是重新启动 X！)。那么如何重新启动 Ⅹ 呢？最简单的方法就是：
直接注销，然后再重新登入即可；
在 X 的画面中直接按下[Alt] + [Ctrl] + [Backspace]
第二个方法比较有趣，[backspace]是退格键，你按下三个按钮后 XWindow 立刻会被重新启动。 如果你的 X Window 因为不明原因导致有点问题时，也可以利用这个方法来重新启动 Ⅹ 喔！
​

### X window 与文本模式的切换

我们前面一直谈到的是 ⅩWindow 的窗口管理员环境，那么在这里面有没有纯文本接口的环境啊？当然有啊！但是，要怎么切换 ⅩWindow 与文本模式呢？注意喔，通常我们也称文本模式为终端机接口,terminal 或 console 喔 ！ Linux 预设的情况下会提供六个 Terminal 来让使用者登入，切换的方式为使
用：[Ctrl] + [Alt] + [F1]~[F6]的组合按钮。
那这六个终端接口如何命名呢，系统会将[F1]～[F6]命名为 tty1 ~ tty6 的操作接口环境。那么如何回到刚刚的 X 窗口接口呢？很简单啊！按下[Ctrl] + [Alt] + [F7]就可以了！我们整理一下登入的环境如下：
[Ctrl] + [Alt] + [F1] ~ [F6] ：文字接口登入 tty1 ~ tty6 终端机 ;
[Ctrl] + [Alt] + [F7] ：图形接口桌面。
在 Linux 默认的登入模式中，主要分为两种，一种是仅有纯文本接口(所谓的执行等级 run level 3)的登入环境，在这种环境中你可以有 tty1~tty6 的终端界面，但是并没有图形窗口接口的环境喔。 另一种则是图形接口的登入环境(所谓的执行等级 run level 5)，这也是我们第四章安装妥当后的预设环境！在这个环境中你就具有 ttty1~tty7 了 ! 其中的 tty7 就是开机完成后的默认等待登入的图形环境！如果你是以纯文本环境启动 Linux 的，预设的 tty7 是没有东西的！万一如此的话，那要怎么启动 X 窗口画面呢？ 你可以在 tty1~tty6 的任意一个终端接口使用你的账号登入后(登入的方法下一小节会介绍)，然后下达如下的指令即可：startx
​

### 下达指令

```
[vbird@www ~]$ command [-options] parameter1 parameter2 ...
								指令			选项			参数(1)			参数(2)
说明：
0. 一行指令中第一个输入的部分绝对是『指令(command)！或『可执行文件
1. command 为指令的名称，例如变换路径的指令为 cd 等等；
2. 中刮号[]并不存在于实际的指令中，而加入选项设定时，通常选项前会带 -
例如 -h；有时候会使用选项的完整全名，则选项前带有一符号，例如
help ;
3.parameter1parameter2.. 为依附在选项后面的参数，或者是command参数；
4.选项,参数等这几个咚咚中间以空格来区分，不论空几格都视为一格
5. 按下[Enter]案件后，该指令就立即执行，[Enter]按键代表着一行指令的开始启动
6. 指令太长的时候，可以使用反斜杠（\）来跳脱[Enter]符号，使指令连续到下行。
	注意！反斜杠后就立刻接特殊字符，才能跳脱！
其他：
a.在Linux 系统中，英文大小写字母是不一样的。举例来说， cd 与 CD 并不同
```

![](https://i.loli.net/2021/12/03/5qAi43OCasZdvQy.png#id=I24Eo&originHeight=228&originWidth=341&originalType=binary∶=1&status=done&style=none#crop=0&crop=0&crop=1&crop=1&id=c7AU1&originHeight=228&originWidth=341&originalType=binary∶=1&rotation=0&showTitle=false&status=done&style=none&title=)

### 重要的几个热键[Tab], [ctrl]-c, [ctrl]-d

[Tab]：命令补全
[ctrl]-c：中断目前程序的挄键
[ctrl]-d：『键盘输入结束(End Of File, EOF 或 End Of Input)』—可以用来取代 exit 的输入
​

### Linux 系统的在线求助 man page 与 info page

因为在 Linux 上开发的软件大多数都是自由软件，而这些软件的开发者为了让大家能够了解指令的用法， 都会自行制作很多的文件，而这些文件也可以直接在在线就能够轻易的被使用者查询出来！这根本就是『联机帮助文件』

### 正确的关机方法

将数据同步写入硬盘中的指令： sync

> 目前的 shutdown/reboot/halt 等等指令均已经在关机前进行了 sync 这个工具。不过，多做几次总是比较放心点
> 普通用户仅可对自己的身份的任务进行数据写入更新，root 账号可以对整个系统进行数据更新

​

惯用的关机指令： shutdown
重新启动，关机： reboot, halt, poweroff
shutdown 可以依据目前已启动的服务来逐次关闭各服务后才关机；至于 halt 却能够在不理会目前系统状况下，进行硬件关机的特殊功能

### 文件系统错误的问题

解决的方法其实很简单，不过因为出错扇区所挂载的目录不同，处理的流程困难度就有差异了。 举例来说，如果你的根目录『/」并没有损毁，那就很容易解决，如果根目录已经损毁了，那就比较麻烦
​

- 无损坏

进入单机维护工作；假如错误是/dev/sda7。输入『 fsck /dev/sda7 』。如果有发现任何的错误时，屏幕会
显示： clear [Y/N]？ 的询问讯息，就直接输入 Y 吧。最终 reboot 重启
​

- 损坏

可以将硬盘拔掉，接到另一台 Linux 系统的计算机上，并且不要挂载(mount)该硬盘，然后以 root 的身份执行『 fsck /dev/sdb1 』；也可以使用近年来径热门的 Live CD
​

- 如果硬盘整个坏掉

能救出来的救出来，然后换一颗硬盘来重新安装 Linux 吧

> 如何预防发生文件系统错误：
> 划分不同的 partition

​

### 忘记 root 密码

以单人维护模式登入即可更改你的 root 密码：
系统启动-->读秒时按“e”进入 grub-->移动至“kernel”一行，再按“e”-->再最后放输入“single”-->回车确认-->按“b”就开机进入单人维护模式。

```
kernel /vmlinuz-2.6.18-128.el5 ro root=LABEL=/ rhgb quiet single
```

> 在这个模式下，你会在 tty1 的地方不需要输入密码即可取得终端机的控制权(而且是使用 root 的身份喔！)

my：根据系统不同自行百度吧。
​

## 第六章 Linux 的档案权限与目录配置

### 使用者与群组

1. 档案拥有者：档案设定成『只有档案拥有者，就是我，才能看与修改这个档案的内容』， 那举即使其他人知道你有这个相当『有趣』的档案，不过由二你有设定适当的权限， 所以其他人自然也就无法知道该档案的内容
1. 群组概念：限制非自己团队(亦即是群组) 的其他人不能够阅览内容！而且亦可以让自己的团队成员可以修改我所建立的档案！ 同时，如果我自己还有私人隐密的文件，仍然可以设定成让自己的团队成员也看不到我的档案数据
1. 其他人的概念：王三毛这个『档案』的拥有者为王三毛，他属二王大毛这个群组， 而张小猪相对于王三毛，则只是一个『其他人(others)』
1. root：他可以到达任何他想要去的地方。

---

**Linux 用户身份与群组记录的档案**

- 默认的情况下，所有的系统上的账号不一般身份使用者，还有那个 root 的相关信息， 都是记录在/etc/passwd 这个档案内的
- 个人的密码则是记录在/etc/shadow 这个档案下
- Linux 所有的组名都记录在/etc/group

---

**Linux 文件属性**

```
ls -al:查看文件属性
```

![](https://s2.loli.net/2021/12/30/TqPzhwDRAXZS4Bn.png#id=YsGGW&originHeight=183&originWidth=504&originalType=binary∶=1&status=done&style=none#crop=0&crop=0&crop=1&crop=1&id=yLYca&originHeight=183&originWidth=504&originalType=binary∶=1&rotation=0&showTitle=false&status=done&style=none&title=)
**第一栏，为档案类型与权限**

- 当为[ d ]则是目录，例如上表档名为 『.gconf』的那一行 ;
- 当为[ - ]则是档案，例如上表档名为 『install.log』那一行 ;
- 若是[Ⅰ]则表示为连结档(link file)；
- 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置) ;
- 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。

​

**接下来的字符中**，以三个为一组，且均为「rwx」 的三个参数的组合。
[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。这三个权限的位置不会改变，如果没有权限，就会出现减号[－]而已。

![](https://s2.loli.net/2021/12/30/Apd9wPoiFxjDLXr.png#id=fOA9Q&originHeight=249&originWidth=620&originalType=binary∶=1&status=done&style=none#crop=0&crop=0&crop=1&crop=1&id=eWkSN&originHeight=249&originWidth=620&originalType=binary∶=1&rotation=0&showTitle=false&status=done&style=none&title=)
第二栏表示有多少档名连结到此节点(i-node)：
第三栏表示这个档案(或目录)的『拥有者账号』
第四栏表示这个档案的所属群组
第五栏为这个档案的容量大小，默认单位为 bytes；
第八栏为这个档案的建档日期或者是最近的修改日期：
第九栏为这个档案的档名：如果档名前多一个『 . 』，则代表这个档案为『隐藏档』

---

**如何改变文件属性的权限**

```
chgrp : 改收变档案所属群组
chgrp [-R] dirname/filename ...
选项与参数：
-R :递归(recursive)的持续变更
```

```
chown ：改变档案拥有者
chown [-R] 账号名称:组名 档案或目录
选项与参数：
-R :递归(recursive)的持续变更
```

```
chmod ：改变档案的权限, SUID, SGID, SBIT 等等的特性
权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更

数字修改权限：r:4;w:2;x:1
chmod [-R] xyz 档案或目录
选顷与参数：
xyz : 就是刚刚提到的数字类型的权限属怅，为 rwx 属性数值的相加。
-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有档案都会变更

符号修改权限
 u, g, o, a ：user, group, others, all
 r, w, x
 +(加入)， -(除去)， =(设定)

 例如： chmod u=rwx,go=rx .bashrc
```

目录与档案之权限意义

- 权限对档案的重要性

r (read)：可读取此一档案的实际内容，如读取文本文件的文字内容等；
w (write)：可以编辑、新增或者是修改该档案的内容(但不含删除该档案)；
x (eXecute)：该档案具有可以被系统执行的权限。
为在 Windows 底下一个档案是否具有执行的能力是藉由『 扩展名 』来判断的，例如：.exe, bat, .com 等等，但是在 Linux 底下，我们的档案是否能被执行，则是藉由是否具有 x 这个权限来决定的！跟档名是没有绝对的关系的

- 权限对目录的重要性
  - r (read contents in directory) :

表示具有读取目录结构列表的权限，所以当你具有读取(r)一个目录的权限时，表示你可以查询该目录下的文件名数据。 所以你就可以利用 Is 这个指令将该目录的内容列表显示出来

- w (modify contents of directory) :

他表示你具有异动该目录结构列表的权限，也就是底下这些权限：建立新的档案与目录；
删除已经存在的档案与目录(不论该档案的权限为何！)
将已存在的档案或目录进行更名；
搬移该目录内的档案、目录位置。

- x (access directory) :

目录的 x 代表的是用户能否进入该目录成为工作目录的用途

---

### Linux 档案种类与扩展名

- 档案种类
  - 正规档案(regular file）:

第一个字符为[-]

```
  - 纯文本档(ASCII)：这是 Linux 系统中最多的一种文件类型啰， 称为纯文本档是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。 几乎只要我们可以用来做为设定的档案都属于这一种文件类型。
  - 二进制文件(binary)：还我们的系统其实仅认识且可以执行二进制文件(binary file)。你的Linux当中的可执行文件(scripts, 文字型批处理文件不算)就是这种格式的
  - 数据格式文件(data)：有些程序在运作的过程当中会读取某些特定格式的档案，那些特定格式的档案可以被称为数据文件（data file）。
```

- 目录(directory) :第一个属性为[d]，例如[drwxrwxrwx]。
- 连结档(link)：就是类似 Windows 系统底下的快捷方式。 第一个属性为[I](%E8%8B%B1%E6%96%87L%E7%9A%84%E5%B0%8F%E5%86%99)，例：[lrwxrwxrwx] ;
- 设备与装置文件(device) :与系统周边及储存等相关的一些档案，通常都集中在/dev 这个目录之下！通常又分为两种：
  - 区块(block)设备档 ：就是一些储存数据，以提供系统随机存取的接口设备，举例来说。硬盘与软盘等。你可以随机的在硬盘的不同区块读写，这种装置就是成组设备
    啰！你可以自行查一下/dev/sda 看看，会发现第一个属性为[ b ]喔！
  - 字符(character)设备文件：亦即是一些串行端口的接口设备，例如键盘、鼠标等等！这些设备的特色就是『一次性读取』的，不能够截断输出。 举例来说，你不可能让鼠标『跳到』另一个画面，而是『滑动』到另一个地方啊！第一个属性为[c]。
- 资料接口文件(sockets) :既然被称为数据接口文件，这种类型的档案通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求，而客户端就可以透过这个 socket 来进行数据的沟通了。第一个属性为[s]，最常在/var/run 这个目录中看到这种文件类型了。
- 数据输送文件（FIFO，pipe）：FIFO 也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个档案所造成的错误问题。 FIFO 是 first-in-first-out 的缩写。第一个属性为[p] 。
- Linux 档案扩展名

Linux 的档案是没有所谓的『扩展名』的，我们刚刚就谈过，一个 Linux 档案能被执行，与他的第一栏的十个属性有关， 与文件名根本一点关系也没有。你的权限当中具有 x 的话，例如[ -rwx-r-xr-x ] 即代表这个档案可以被执过，但可以被执行跟可以执行成功是不一样的。
虽然如此，不过我们还是希望可以藉由扩展名来了解该档案是什么东西，所以， 通常我们还是会以适当的扩展名来表示该档案是什么种类的。底下有数种常用的扩展名

- \*.sh：脚本或批处理文件（scripts），因为批处理文件为使用 shell 写成的，所以扩展名就编成 .sh 啰 ;
- _Z, _.tar, _.tar.gz, _.zip, \*.tgz ：经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名啰！
- _.html, _.php：网页相关档案，分别代表 HTML 语法与 PHP 语法的网页档案啰！ .html 的档案可使用网页浏览器来直接开启，至于 .php 的档案，则可以透过 client 端的浏览器来 server 端浏览

基本上，Linux 系统上的文件名真的只是让你了解该档案可能的用途而已， 真正的执行还是要看权限的规范
上述的这种问题最常发生在档案传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行！呵呵！那举就是可能档案的属性被改变了

- Linux 档案长度限制：

在 Linux 底下，使用预设的 Ext2/Ext3 文件系统时，针对档案的档名长度限制为：
单一档案或目彔的最大容量文件名为 255 个字符；
包括完整路径名称及目彔 (/) 之完整档名为 4096 个字符。

- Linux 文件名的限制：

由于 Linux 在文字接口下的些指令操作关系般来说，你在设定 Linux 底下的文件名时，最好可
以避免一些特殊字符比较好！例如底下这些：\*？> <;&![]|""(){}
因为这些符号在文字接口下，是有特殊意义的！另外，文件名的开头为小数点『.』时，代表这个档案为『隐藏档』喔！同时，由于指令下达当中，常常会使用到 -option 之类的选项， 所以你最好也避免将档案档名的开头以 - 或 + 来命名啊！

---

### Linux 目录配置

- 根据 FHS([http://www.pathname.com/fhs/)](http://www.pathname.com/fhs/))的官方文件指出，他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下， 所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的用户，都能够遵循 FHS 的标准。 也就是说，FHS 的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。

FHS 依据文件系统使用的频繁与是否允许使用者随意更动， 而将目录设定成为四种交互作用的形态，用表格来说有点像底下这样：

|

| 可分享的(shareable) | 不可分享的(unshareable)    |
| ------------------- | -------------------------- |
| 不变的(static)      | /usr(软件放置处)           |
|                     | /opt (第三方协力软件)      |
| 可变动的(variable)  | /var/mail (使用者邮件信箱) |
|                     | /var/spool/news (新闻组)   |

```
可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据，是
能够分享给网络上其他主机挂载用的目录；

不可分享的：自己机器上面运作的装置档案或者是与程序有关的 socket 档案等， 由于仅与自身
机器有关，所以当然就不适合分享给其他主机了。

不变的：有些数据是不会经常变动的，跟随着 distribution 而不变动。 例如函式库、文件说明
文件、系统管理员所管理的主机服务配置文件等等；

可变动的：经常改变的数据，例如登录文件、一般户可自行收受的新闻组等。
```

---

- 根目录 (/) 的意义与内容：

FHS 标准建议：根目录(/)所在分割槽应该越小越好，且应用程序所安装的软件最好不要与根目录同一个分割槽内，保持根目录越小越好。如此不但效能较佳，根目录所在的文件系统也较不容易问题。
​

| 目录 | 应放置档案内容 |
| ---- | -------------- |
| /bin |                |

| 系统有很多放置执行文件的目录，但/bin 比较特殊。因为/bin 放置的是在单人维护模式下还能够被操作的指令。在/bin 底下的指令可以被 root 与一般账号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash 等等常用的指令。 |
| /boot | 这个目录主要在放置开机会使用到的档案，包括 Linux 核心档案以及开机选单与开机所需配置文件等等。 Linux kernel 常用的档名为：vmlinuz，如果使用的是 grub 这个开机管理程序，则还会存在/boot/grub/这个目录 |
| /dev | 在 Linux 系统上，任何装置与接口设备都是以档案的型态存在于这个目录当中的。 你只要透过存取这个目录底下的某个档案， 比要重要的档案有
/dev/null,/dev/zero,/dev/tty,/dev/lp*,/dev/hd*,/dev/sd\*等等 |
| /etc | 系统主要的配置文件几乎都放置在这个目录内，例如人员的账号密码文件、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但
是只有 root 有权力修改。FHS 建议不要放置可执行文件(binary)在这个目录中喔。比较重要的档案有：/etc/inittab,/etc/init.d/,/etc/modprobe.conf,/etc/X11/,
/etc/fstab, /etc/sysconfig/等等。另外，其下重要的目录有：

- /etc/init.d/：所有服务的预设启动 script 都是放在这里的，例如要启动或者关/etc 闭 iptables 的话：『/etc/init.d/iptables start』、『/etc/init.d/iptablesstop』
- /etc/xinetd.d/：这就是所谓的 super daemon 管理的各项服务的配置文件目录。
- /etc/X11/：与 X Window 有关的各种配置文件都在这里，尤其是 xorg.conf 这个 ⅩServer 的配置文件。
  |
  | /home
  | 这是系统默认的用户家目录(home directory)。在你新增一个一般使用者账号时， 默认的用户家目录都会规范到这里来。比较重要的是，家目录有两种代号喔：
  ~：代表目前这个用户的家目录，而
  ~dmtsai : 则代表 dmtsai 的家目录！ |
  | /lib
  | 系统的函式库非常的多，而/lib 放置的则是在开机时会用到的函式库， 以及在/bin 或/sbin 底下的指令会呼叫的函式库而已。 什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程序的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模块(驱动程序)喔！ |
  | /media

| media 是『媒体』的英文，顾名思义，这个/media 底下放置的就是可移除的装置。包括软盘、光盘、DVD 等等装置都暂时挂载于此。常见的档名有：
/media/floppy,/media/cdrom 等等。 |
| /mnt
| 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。 在古早时候，这个目录的用途与/media 相同啦！只是有了/media 之后，这个目录就用来暂时挂载用了。 |
| /opt
| 这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？举例来说，KDE 这个桌面管理系统是一个独立的计划，不过他可以安装到 Linux 系统中，因此 KDE 的软件就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软件(非原本的 distribution 提供的)，那么也能够将你的软件安装到这里来。 不过，以前的 Linux 系统中，我们还是习惯放置在/usr/local 目录下呢！ |
| /root | 系统管理员(root)的家目录。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有 root 的家目录，所以我们会希望 root 的家目录与根
目录放置在同一个分割槽中。 |
| /sbin

| Linux 有非常多指令是用来设定系统环境的，这些指令只有 root 才能够利用来『设定』系统，其他用户最多只能用来『查询』而已。 放在/sbin 底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统执行文件(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck,ifconfig, init, mkfs 等等。 |
| /srv | srv 可以视为「service』的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如 WWW, FTP 等等。举例来说，WWW 服务器需要的网页
资料就可以放置在/srv/www/里面。 |
| /tmp

| 这是让一般用户或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！因为 FHS 甚至建议在开机时，应该要将/tmp 下的数据都删除唷！ |

亊实上 FHS 针对根目录所设定的标准就仅有上面的，不过我们的 Linux 底下还有讲多目录你也需
要了解一下的。 底下是几个在 Linux 当中也是非常重要的目录：

| 目录                                                                                                                                                                                                                                                           | 应放置档案内容                                                                                                                                                                                                                                                                        |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| /lost+found                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                       |
| 这个目录是使用标准的 ext2/ext3 文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时，将一些遗失的片段放置到这个目录下。这个目录通常会在分割槽的最顶层存在，例如你加装一颗硬盘于/disk 中，那在这个系统下就会自动产生一个这样的目录 『/disk/lost+found』 |                                                                                                                                                                                                                                                                                       |
| /proc                                                                                                                                                                                                                                                          | 这个目录本身是一个『虚拟文件系统(virtual filesystem)』喔！他放置的数据都是在内存当中，例如系统核心、行程信息(process)、周边装置的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的档案例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, |
| /proc/ioports, /proc/net/\*等等。                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                       |
| /sys                                                                                                                                                                                                                                                           | 这个目录其实跟/proc 非常类似，也是一个虚拟的文件系统，主要也是记录与核心相关的信息。 包括目前已加载的核心模块与核心侦测到的硬件装置信息等等。这个目录同样不占硬盘容量喔！                                                                                                             |

- /usr 的意义与内容：

usr 是 Unix Software Resource 的缩写， 也就是『Unix 操作系统软件资源』所放置的目录
所有系统默认的软件(distribution 发布者提供的软件)都会放置到/usr 底下，因此这个目录有点类似 Windows 系统的『C:\Windows\ + C:\Program files\』这两个目录的综合体

- /var 的意义与内容：

/var 就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var 目录彔主要针对经常变动的档案，包括快取(cache)、登录彔档(log file)以及某些软件运作所产生的档案， 包括程序档案(lock file, run file)，或者例如 MySQL 数据库的档案等等

- 针对 FHS，各家 distributions 的异同

由于 FHS 仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的档案或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。举例来说，CentOS 的网络设定数据放在/etc/sysconfig/network-scripts/ 目录下，但是 SuSE 则是将网络放置在 /etc/sysconfig/network/ 目录下，目录名称可是不同的。不过只要记住大致的 FHS 标准，差异性其实是有限的。

---

**目录树(directory tree)**

- 目录树有主要特征
  - 目录树的启始点为根目录(/,root);
  - 每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem。举例来说，可以利用 Network File System (NFS) 服务器挂载某特定目录等。
  - 每一个档案在此目录树中的文件名(包含完整路径)都是独一无二的。

![](https://s2.loli.net/2021/12/30/dQ9TuRySpXjO5as.png#id=s14hG&originHeight=636&originWidth=587&originalType=binary∶=1&status=done&style=none#crop=0&crop=0&crop=1&crop=1&id=YXLJ7&originHeight=636&originWidth=587&originalType=binary∶=1&rotation=0&showTitle=false&status=done&style=none&title=)

---

**绝对路径与相对路径**

- 绝对路径：由根目录(/)开始写起的文件名或目录名称，例如 /home/dmtsai/.bashrc ;
- 相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 ../../home/dmtsai/等等。

反正开头不是／就属于相对路径的写法
. ：代表当前的目录，也可以使用 ./ 来表示；
.. ：代表上一层目录，也可以 ../ 来代表。

---

**CentOS 的观察**

```
[root@www ~]# uname -r
2.6.18-128.el5 <==可以察看实际的核心版本
[root@www ~]# lsb_release -a
LSB Version: :core-3.1-amd64:core-3.1-ia32:core-3.1-noarch:graphics-
3.1-amd64:
graphics-3.1-ia32:graphics-3.1-noarch <==LSB 的版本
Distributor ID: CentOS
Description: CentOS release 5.3 (Final) <==distribution 的版本
Release: 5.3
Codename: Fina
```

## 第七章 Linux 的档案权限与目录配置

**目录与路径**

1. **相对路径与绝对路径**

相对路径意指【相对于目前工作目录】

---

#### 目录的相关操作

**1 cd：变换目录**

```
[root@www /]# cd -
# 表示回到刚刚的那个目录，也就是 /root 啰～
```

**2 pwd :显示当前目录**
pwd -P:显示真实路径。例如：联结档
**3 mkdir：建立个新的目录**
选项与参数 :
-m ：配置文件案的权限喔！直接设定，不需要看预设权限 (umask)
-p 帮助你直接将所需要的目录(包含上层目录)递归建立起来！
**4 rmdir :删除空的目录**
选项与参数 :-p:递归删除

---

#### 执行文件路径的变量：$PATH

echo $PATH：显示当前 PATH 变量

---

#### 档案与目录管理

```
ls [参数] 目录名称
选项与参数：
-d:仅列出目录本身，而不显示目录内的档案数据
-l:长数据串行出，包含档案的属性与权限等等数据
```

1. cp(复制档案或目录）

选项与参数：
-a:当我们在进行备份的时候，某些需要特别注意的特殊权限档案，例如密码文件（/etc/shadow）以及一些配置文件，就不能直接以 cp 来复制，而必须要加上 -a 或者是 -p 等等
-f:若目标文件已经存在时，再覆盖时会先询问动作的进行
-p:连同档案的属性一起复制过去，而非使用默认属性
-r:递归持续复制，用于目录的复制行为

2. rm(移除档案或目录）

-r:递归删除
-i:互动模式

3. mv(移动档案与目录，或更名)

-f:强制
-i:若目标档案已存在，会询问是否删除

4. 档案内容查阅：

cat：由第一行开始显示档案内容
tac：从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
nl：显示的时候，顺道输出行号！
more：一页一页的显示档案内容
less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
head：只看头几行
tail ：只看尾巴几行
od：以二进制的方式读取档案内容！

5. 修改档案时间或建置新档：touch
   1. 三种时间状态
      1. mtime:当“内容数据”发生变更时，就会更新这个时间
      1. ctime:当“状态”变更时，就会更新这个时间。例如：权限
      1. atime:当“档案的内容被取用”时，就会更新这个读取时间
   2. 最常用的用法
      1. 建立一个空档案
      1. 修订档案日期

---

#### 档案与目录的默认权限与隐藏权限

6. 档案预设权限：umask

参数：
不加参数：以数字的方式代表 7 减去 x。x 为数字。假如数字为 0，即 7-0=7。即拥有 rwx 权限
-S:以符号类型的方式显示出权限

7. 档案隐藏属性：
   1. chattr(配置文件案隐藏属性）

```
chattr [+-=][ASacdistu] 档案或目录名称
选项与参数 :
+：增加某一个特殊参数，其他原本存在参数则不动。
-：移除某一个特殊参数，其他原本存在参数则不动。
=：设定一定，且仅有后面接的参数

A:当设定了 A 这个属性时，若你有存取此档案(或目录)时，他的访问时间
atime
	将不会被修改，可避免I/O 较慢的机器过度的存取磁盘。这对速度较慢的计
算机有帮助
S：一般档案是异步写入磁盘的(原理请参考第五章 sync的说明)，如果加上 S
这个
	属性时，当你进行任何档案的修改，该更动会『同步」写入磁盘中。
a：当设定 a 之后，这个档案将只能增加数据，而不能删除也不能修改数据
	只有 root才能设定这个属性。
c：这个属性设定之后，将会自动的将此档案『压缩』，在读取的时候将会自动
解压缩，
	但是在储存的时候，将会先进行压缩后再储存(看来对于大档案似乎蛮有用
的！）

d:当dump程序被执行的时候，设定 d 属性将可使该档案(或目录)不会被
dump 备份
i：他可以让一个档案『不能被删除、改名、设定连结也无法写入或新增资料！」对于系统安全性有相当大的帮助！只有 root 能设定此属

s：当档案设定了 s 属性时，如果这个档案被删除，他将会被完全的移除出这个
硬件空间，所以如果误删了，完全无法救回来了喔！
u：与 s 相反的，当使用 u 来配置文件案时，如果该档案被删除了，则数据内容其实还
存在磁盘中，可以使用来救援该档案喔！
```

8. lsattr(显示档案隐藏属性）

选项与参数：
-a：显示隐藏文件的属性
-d:如果接的是目录，仅显示目录本身的属性而非目录内的文件名
-R:连同子目录的数据也一并列出来

9. 档案特殊权限;

设置特殊权限后，对应位置应出现小写 s。若为大写 S，即特殊权限的执行者也没有权限执行。即空权限

1.  SUID

- SUID 权限仅对二进制程序(binary program)有效；
- 执行者对于该程序需要具有 x 的可执行权限；
- 本权限仅在执行该程序的过程中有效（run-time）;
- 执行者将具有该程序拥有者 (owner)的权限。

2.  SGID

- SGID 对二进制程序有用；
- 程序执行者对于该程序来说，需具备 x 的权限；
- 执行者在执行的过程中将会获得该程序群组的支持！

与 SUID 非常类似。对项目开发来说非常重要。涉及群组权限

3.  SBIT

仅对目录有效，对档案没有效果

- 当用户对于此目录具有 w，x 权限，亦即具有写入的权限时；
- 当用户在该目录下建立档案或目录时，仅有自己与 root 才有权力删除该档案

---

#### 观察文件类型:file

如果你想要知道某个档案的基本数据，例如是属于 ASCII 或者是 data 档案，或者是 binary，且其中有没有使用到动态函式库（share library）等等的信息，就可以利用 file 这个指令来检阅

---

#### 指令与档案的搜索

10. 脚本文件名的搜寻：
1. which（寻找【执行档】）

选项或参数：
-a:将所有 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称

11. 档案档名的搜寻：
1. whereis(寻找特定档案)

Linux 系统会将系统内的所有档案都记录在一个数据库档案里面，而当使用 whereis 或者是底下要说的 locate 时，都会以此数据库档案的内容为准， 因此，有的时后你还会发现使用这两个执行档时，会找到已经被杀掉的档案！而且也找不到最新的刚刚建立的档案呢！
参数与选项：
-b:只找 binary 格式的档案
-m：只找在说明文件 manual 路径下的档案
-s:只找 source 来源档案
-u:搜寻不在上述三个项目当中的其他特殊档案

2.  locate

locate 寻找的数据是由『已建立的数据库 /var/lib/mlocate/』 里的，不用直接在去硬盘当中存取数据
选项与参数:
-i:忽略大小写的差异 ;
-r:后面可接正规表示法的显示方式

---

#### 更新数据库指令：updatedb

根据 /etc/updatedb.conf 的设定去搜寻系统硬盘内的文件名，并更新/var/lib/mlocate 内的数据库档案；

---

3.  find

选项与参数 :

      1. 与时间有关的选项：

-mtime n : n 为数字，意义为在 n 天之前的【一天之内！被更动过内容的档案】
-mtime +n : 列出在 n 天之前(不含 n 天本身)被更动过内容的档案档名 ;
-mtime -n : 列出在 n 天之内(含 n 天本身)被更动过内容的档案档名.
-newert file ：file 为一个存在的档案，列出比 file 还要新的档案档名

      2. 与使用者或组名有关的参数：

-uid n：n 为数字，这个数字是用户的账户 ID，即 UID
/etc/passwd 里面与账号名称对应的数字
-gid n ：n 为数字，这个数字是组名的 ID，亦即 GID，
这个 GID 记录在/etc/group
-user name : name 为使用者账号名称
-group name : name 为组名，例如 users ;
-nouser：寻找档案的拥有者不存在 /etc/passwd 的人 ！
-nogroup：寻找档案的拥有群组不存在于 /etc/group 的档案！
当你自行安装软件时，很可能该软件的属性当中并没有档案拥有者这是可能的！在这个时候，就可以使用-nouser 与-nogroup 搜寻

      3. 与档案权限及名称有关的参数：

-name filename：搜寻文件名为 filename 的档案
-size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的档案。这个 SIZE 的规格有：c: 代表 byte ,k: 代表 1024bytes。所以，要找比 50KB 还要大的档案，就是『-size +50k ]
-type TYPE：搜寻档案的类型为 TYPE 的，类型主要有：一般正规档案(f),装置档案 (b, c), 目录 (d), 连结档 (l), socket (s),及 FIFO (p) 等属性。
-perm mode：搜寻档案权限『刚好等于」mode 的档案，这个 mode 为类似 chmod 的属性值。举例来说，-rwsr-xr-x 的属性为 4755 !
【必须全部囊括 mode 的权限，即 4755】
-perm +mode:搜索档案权限【包含任一 mode 的权限】的档案。即 4755 的档案，可以-perm -0777
​

## 第八章 Linux 磁盘与文件系统管理

### 认识 EXT2 文件系统

1. 文件系统特征
   1. 格式化

为什么需要进行『格式化』呢？这是因为每种操作系统所设定的文件属性/权限并不相同， 为了存放这些档案所需的数据，因此就需要将分割槽进行格式化，以成为操作系统能够利用的『文件系统格式(filesystem)』。
但现在已经有新技术可以将一个分割槽格式划分多个文件系统（例如 LVM），也能将多个分割槽合成一个文件系统（LVM,RAID）

2.  如何运作
    1. inode（权限与属性区块）

例如 Linux 的档案权限（rwx）

      2. block（实际数据区块）

实际记录档案的内容，若档案太大，会占用多个 block

      3. superblock（超级区块）

记录整个文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量等

3.  如何读取
    1. 索引式文件系统

通过读取 inode 的信息来确定 block 号码

      2. FAT文件系统

不存在 inode，所以每个区块记录下一个区块的信息。因此需要磁盘整理

2. linux 的 EXT2 文件系统

Ext2 文件系统在格式化的时候基本上是区分为多个区块群组 (block group)的，每个区块群组都有独立的 inode/block/superblock 系统
![](https://s2.loli.net/2022/01/14/kgG6LIS1cKOXb89.png#crop=0&crop=0&crop=1&crop=1&id=D78o7&originHeight=190&originWidth=362&originalType=binary∶=1&rotation=0&showTitle=false&status=done&style=none&title=)

1.  data block（资料区块）
    | block 大小 | 1kb | 2kb | 4kb |
    | --- | --- | --- | --- |
    | 最大单一档案限制 | 16gb | 256gb | 2tb |
    | 最大文件系统总容量 | 2tb | 8tb | 16tb |

          1. 基本限制
          - 原则上，block的大小与数量在格式化完就不能够再改变了(除非重新格式化)；
          - 每个 block 内最多只能够放置一个档案的数据；
          - 承上，如果档案大于 block的大小，则一个档案会占用多个 block 数量；
          - 承上，若档案小于 block，则该 block 的剩余容量就不能够再被使用了(磁盘空间会浪费)。

2.  inode table(inode 表格)
    1. 数据内容
    - 该档案的存取模式(read/write/excute) ;
    - 该档案的拥有者与群组(owner/group)；
    - 该档案的容量；
    - 该档案建立或状态改变的时间(ctime) ;
    - 最近一次的读取时间(atime)；
    - 最近修改的时间(mtime)；
    - 定义档案特性的旗标(flag)，如 SetUID.
    - 该档案真正内容的指向 (pointer) ;
    2. 特征
    - 每个 inode 大小均固定为 128bytes；
    - 每个档案都仅会占用一个 inode 而已；
    - 承上，因此文件系统能够建立的档案数量与 inode 的数量有关；
    - 系统读取档案时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够开始实际读取 block 的内容。
    3. 遇到大文件时

![](https://s2.loli.net/2022/01/14/wa5bVl4cshU8ngC.png#crop=0&crop=0&crop=1&crop=1&id=wfzxX&originHeight=435&originWidth=554&originalType=binary∶=1&rotation=0&showTitle=false&status=done&style=none&title=)

3.  superblock（超级区块）
    1. 主要信息
    - block 与 inode 的总量 ;
    - 未使用与已使用的 inode / block 数量；
    - block 与 inode 的大小 (block 为 1, 2, 4K , inode 为 128 bytes) ;
    - filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 (fsck) 的时间等文件系统的相关信息；
    - 一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0，若未被挂载，则 valid bit 为 1
4.  Filesystem Description (文件系统描述说明)

这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段 (superblock,bitmap, inodemap, data block) 分别介亍哪一个 block 号码之间

5.  block bitmap (区块对照表)

从 block bitmap 当中可以知道哪些 block 是空的，因此我们的系统就能够很快速的找到可使用的空间来处置档案

6.  inode bitmap (inode 对照表)

inode bitmap 则是记录使用不未使用的 inode 号码

---

7.  与目录树的关系
    1. 目录

当我们在 Linux 下的 ext2 文件系统建立一个目彔时， ext2 会分配一个 inode 不至少一块 block 给该目录。其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块 block 号码； 而 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。

      2. 档案

建立一般档案时，ext2 会分类一个 inode 相对于该档案大小的 block 数量给该档案

      3. file system大小与磁盘读取效能

随着文件系统增大，数据可存在的区块增多。分散的概率也就增大，随着数据分散，最终可能会导致低效读取的出现

      4. 数据不一致状态

在早期的 Ext2 文件系统中，如果发生意外断电等错误，导致数据没有正常写入。 那系统在重新启动的时候，就会藉由 Superblock 当中记录的 valid bit (是否有挂载) 与 filesystem state (clean 与否) 等状态来判断是否强制强行数据一致性的检查！

         1. 日志式文件系统

如果在我们的 filesystem 当中规划出一个区块，该区块专门在记录写入或修订档案时的步骤， 那不就可以简化一致性检查的步骤了？也就是说：

            1. 预备：当系统要写入一个档案时，会先在日志记录区块中纪录某个档案准备要写入的信息；
            1. 实际写入：开始写入档案的权限与数据；开始更新 metadata 的数据；
            1. 结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该档案的纪录。

---

8.  Linux 文件系统的运作

Linux 使用的方式是透过一个称为异步处理：
当系统加载一个档案到内存后，如果该档案没有被更动过，则在内存区段的档案数据会被设定为干净(clean)的。 但如果内存中的档案数据被更改过了(例如你用 nano 去编辑过这个档案)，此时该内存中的数据会被设定为脏的 (Dirty)。此时所有的动作都还在内存中执行，并没有写入到磁盘中！系统会不定时的将内存中设定为 [Dirty』的数据写回磁盘，以保持磁盘与内存数据的一致性。
可以通过 sync 来强制内存中设定为“Dirty”的档案写回到磁盘中

9.  挂载点的意义

挂载点一定是目录，该目录为进入该文件系统的入口

10. linux VFS

整个 Linux 的系统都是透过一个名为 Virtual Filesystem Switch 的核心功能去读取 file system 的

---

### 文件系统的简单操作

1. 磁盘与目录的容量
   1. 磁盘与目录的容量：
      1. df：列出文件系统的整体磁盘使用量

-h：以人们较易读的容量格式 (G/M) 显示

      2. du：评估文件系统的磁盘使用量（常用于在推估目录所占容量）

---

2. 实体链接与符号链接：ln [-sf] 来源文件 目标文件

选项与参数：
-s ：如果不加任何参数就进行连结，那就是 hard link，至亍 -s 就是 symbolic
link
一种是类似 Windows 的快捷方式功能的档案，可以帮助你快速的链接到目标档案(或目录)； 另一种则是透过文件系统的 inode 连结来产生新档名，而不是产生新档案！这种称为实体链接 (hard link)。

1.  Hard Link (实体链接, 硬式连结或实际连结)

hard link 只是再某个目录下新增一笔档名链接到某 inode 号码的关连记录

2.  Symbolic Link (符号链接，亦即是快捷方式)

直接指向读取他 link 的那个档案的档名

3.  1
4.  1
5.  1

---

### 磁盘的分割、格式化、检验与挂载

### 设定开机挂载

### 内存置换空间（swap）之建置

### 文件系统的特殊观察与操作

1. 1
1. 1
1. 11

1
1
11
11
1
​

​

​

4. 1
