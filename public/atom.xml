<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LZL</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liaozonglong.github.io/"/>
  <updated>2022-02-24T08:20:03.146Z</updated>
  <id>http://liaozonglong.github.io/</id>
  
  <author>
    <name>liaozonglong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库综述</title>
    <link href="http://liaozonglong.github.io/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%BC%E8%BF%B0/"/>
    <id>http://liaozonglong.github.io/wiki/数据库综述/</id>
    <published>2022-02-22T03:27:19.000Z</published>
    <updated>2022-02-24T08:20:03.146Z</updated>
    
    <content type="html"><![CDATA[<p>书籍来源：Abraham Silberschatz 等：数据库系统概念@2006 (第 5 版 扫描版).pdf<br>​</p><ol><li>1.1-1.7 数据库本身概念介绍</li></ol><p>1.7-1.9 数据库用户介绍</p><ol start="2"><li>第二章 对数据库的设计理念进一步延伸，实体与联系模型</li></ol><p>第三章应该是基于第二章的技术概念上的一次升级</p><ol start="3"><li>第四章——SQL 单独介绍、第五章——其他的类型介绍，予读者一种对比</li></ol><p>​</p><p>概念书，从设计理念到实际设计都有描述</p><hr><p>DBMS（数据库管理系统）：由一个互相关联的数据的集合和一组用以访问这些数据程序组成，这个数据集合通常被称为数据库</p><ol><li><strong>数据库概念</strong><ol><li><strong>数据库系统的目的——解决问题</strong><ol><li>数据的冗余和不一致</li><li>数据孤立</li><li>完整性问题</li><li>数据访问困难</li><li>原子性问题</li><li>并发访问异常</li><li>安全性问题</li><li>……</li></ol></li><li><strong>数据视图——系统隐藏关于数据存储和维护的某些细节</strong><ol><li><strong>数据抽象</strong><ol><li><strong>用户界面</strong><ol><li>物理层——最低层次的抽象，描述数据实际上怎么存储</li><li>逻辑层——高于物理层，描述数据库中存储什么数据，以及数据之间的关系</li><li>视图层——最高层次的抽象，但只描述整个数据库的某个部分</li></ol></li></ol></li><li><strong>实例和模式</strong></li></ol></li></ol></li></ol><p>数据库模式：数据库总体设计<br>数据库实例：存储在数据库中的信息的集合</p><pre><code>  3. **数据独立性**</code></pre><p>数据独立性：在某个层次上修改模式定义而不影响位于其上一层模式的能力</p><ol start="3"><li><strong>数据模型</strong></li></ol><p>数据模型：描述数据、数据联系、数据语义及一致性约束的概念工具的集合</p><pre><code>  1. **基于对象的逻辑模型**</code></pre><p>用于在逻辑层和视图层上描述数据</p><pre><code>     1. **实体-联系模型（E-R）**</code></pre><p>该模型基于对现实世界的一种认识：现实世界是由一组称作实体的基本对象以及这些对象间的联系构成的</p><pre><code>        - E-R图           - 矩形：代表实体集           - 椭圆：代表属性           - 菱形：代表实体集间的联系           - 段：将属性与实体集相连或将实体集与联系相连     2. **面向对象的模型**</code></pre><p>面对对象的模型是基于对象的一个集合。<br>对象划分为不同的类，含有相同类型的值和相同方法的对象属于同一个类。</p><pre><code>     3. **基于记录的逻辑模型**</code></pre><p>基于记录的模型既用来定义数据库的全局逻辑结构，又用来提供关于实现的高层描述</p><pre><code>        1. **关系模型**</code></pre><p>用表的集合来表示数据和数据间的关系</p><pre><code>        2. **网状模型**</code></pre><p>数据用记录的集合来表示</p><pre><code>        3. **层次模型**</code></pre><p>与网状模型类似，分别用记录和链接来表示数据和数据间的联系</p><pre><code>        4. **三种模型的差别**</code></pre><p>关系模型同其他的不同在于关系模型不适用指针或链接，而是通过记录所包含的值把记录联系起来。这样的方式可以为关系模型定义规范的数学基础</p><pre><code>     4. **物理数据模型**</code></pre><p>最低层次上描述数据。不在本书讨论范围内</p><ol start="4"><li><strong>数据库语言</strong><ol><li><strong>数据定义语言（DDL）</strong></li></ol></li></ol><p>DDL(数据定义语言)——该语句的编译结构是产生了存储在一个特殊文件中的一系列表，称作数据字典或数据目录<br>数据库中定义存储结构和访问方式由 DDL 语句来定义<br>数据字典：一个包含元数据的文件，元数据是关于数据的数据。数据库，实际的读取修改前总要先查询该表</p><pre><code>  2. **数据操纵语言(DML)**</code></pre><p>数据操作——增删查改<br>两类数据操纵语言：</p><pre><code>     - 过程化的DML要求用户指定要什么数据以及如何获取     - 非过程化的DML要求用户要什么数据，而不需要指明如何获取</code></pre><ol start="5"><li><strong>事务管理</strong></li></ol><p>按几个操作合起来形成一个逻辑执行单元<br>事务管理是数据库应用中完成单一逻辑功能的操作集合</p><ol start="6"><li><strong>存储管理</strong></li></ol><p>数据库系统对数据的组织必须满足使磁盘和主存间数据移动的需求最小化<br>存储管理器负责与文件管理器交互——通过 DML 语句翻译成底层文件系统命令<br>存储管理器负责数据库中的数据存储、检索和更新</p><ol start="7"><li><strong>数据库管理员（DBA）</strong></li></ol><p>数据库管理员：对系统进行集中控制的人<br>责任：</p><pre><code>  - 模式定义  - 存储结构及存取方式定义  - 模式及物理组织的修改  - 数据访问授权  - 完整性约束的定义</code></pre><ol start="8"><li><strong>数据库用户</strong></li></ol><p>四种类型：</p><pre><code>  - 应用程序设计人员——编写通过DML调用的程序，与系统交互  - 富有经验的用户——并非通过编写语言来同系统交互，而是用数据库查询语言来交互  - 专门的用户——编写专门的、不适用传统的模式的富有经验的用户  - 没有经验的用户——通过已经写好的程序同数据库进行交互</code></pre><ol start="9"><li><strong>系统总体结构</strong></li></ol><p>大致可以分成——查询处理器部件、存储管理器部件</p><pre><code>  - 查询处理器部件     - DML编译器：将DML翻译成引擎能理解的低级指令     - 嵌入式DML预编译器：将嵌在应用程序中的DML转换成宿主语言中普遍的过程调用语句，必须同DML编译器相配合     - DDL解释器：解释DDL语句并将其记录到包含元数据的一系列表中     - 查询求值引擎  - 存储管理器部件     - 权限及完整性管理器     - 事务管理器     - 文件管理器     - 缓冲管理器     - 一些数据结构        - 数据文件        - 数据字典        - 索引        - 统计数据</code></pre><p>​</p><p>​</p><p>​</p><hr><p>LZL:</p><ol><li>任何系统都是为了解决问题而生</li><li>知道如何用，不知道为什么这样用。这是可行的策略。——这可能仅适用于被设计出来的东西</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;书籍来源：Abraham Silberschatz 等：数据库系统概念@2006 (第 5 版 扫描版).pdf&lt;br&gt;​&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1.1-1.7 数据库本身概念介绍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1.7-1.9 数据库用户介绍&lt;/p&gt;
&lt;ol start=
      
    
    </summary>
    
    
      <category term="​" scheme="http://liaozonglong.github.io/tags/%E2%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit 渗透测试指南</title>
    <link href="http://liaozonglong.github.io/wiki/Metasploit%20%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://liaozonglong.github.io/wiki/Metasploit 渗透测试指南/</id>
    <published>2022-02-21T03:16:59.000Z</published>
    <updated>2022-02-24T08:20:03.146Z</updated>
    
    <content type="html"><![CDATA[<p>结构笔记：</p><ol><li>这是什么样的一本书？</li></ol><p>带有针对性的工具书，主要是为了让你理解某个工具</p><ol start="2"><li>整本书在谈的是什么？</li></ol><p>核心是围绕 meterpreter mixins 来展开。一切其他方面的补充都是为了更好理解 meterpreter mixins</p><ol start="3"><li>作者是借着怎样的整体架构，来发展他的观点或陈述他对这个主题的理解？<ol><li>标准化的基础知识</li><li>一些术语解释（应该顺带介绍这个程序）</li><li>各种情报扫描工具、各种漏洞扫描（结合两者进行一次攻击行为）——理解标准攻击的行为</li><li>正式开始 meterpreter 相关内容（攻击行为）</li><li>具备攻击后，加强反杀能力</li><li>一些其他的攻击手段</li><li>从创建一个攻击代码到组成 metasploit 框架的一部分</li><li>整个行为的总结</li></ol></li><li>附录让你开放可能存在的漏洞并进行攻击。这是理解这个应用更好的方法</li></ol><p>一个很普通的指南书，目的是 meterpreter 框架。作者每次让读者看框架执行之前总会从常规模式入手，让读者理解这一模式。因此，理解前者是理解后者的基础，并且也占比绝大部分。<br>​</p><p>##渗透测试的基础<br>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;结构笔记：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是什么样的一本书？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;带有针对性的工具书，主要是为了让你理解某个工具&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;整本书在谈的是什么？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;核心是围绕 meterpreter mix
      
    
    </summary>
    
    
      <category term="​" scheme="http://liaozonglong.github.io/tags/%E2%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>丽晶打印机更换打印格式</title>
    <link href="http://liaozonglong.github.io/wiki/%E4%B8%BD%E6%99%B6%E6%89%93%E5%8D%B0%E6%9C%BA%E6%9B%B4%E6%8D%A2%E6%89%93%E5%8D%B0%E6%A0%BC%E5%BC%8F/"/>
    <id>http://liaozonglong.github.io/wiki/丽晶打印机更换打印格式/</id>
    <published>2022-02-18T05:43:23.000Z</published>
    <updated>2022-02-24T08:20:03.219Z</updated>
    
    <content type="html"><![CDATA[<p>针打机格式：<br><img src="https://s2.loli.net/2021/12/15/gTD1riJWAyhNzYf.png#crop=0&crop=0&crop=1&crop=1&id=FfkJL&originHeight=186&originWidth=745&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;针打机格式：&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2021/12/15/gTD1riJWAyhNzYf.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=FfkJL&amp;originHeight=186&amp;originWidth=
      
    
    </summary>
    
    
      <category term="丽晶" scheme="http://liaozonglong.github.io/tags/%E4%B8%BD%E6%99%B6/"/>
    
  </entry>
  
  <entry>
    <title>hexo</title>
    <link href="http://liaozonglong.github.io/wiki/hexo/"/>
    <id>http://liaozonglong.github.io/wiki/hexo/</id>
    <published>2022-02-18T05:16:39.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<ol><li>install nodejs npm Git yay</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S yay</span><br><span class="line">yay -S nodejs npm</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ol start="2"><li>station construction</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">git clone https://github.com/zthxxx/hexo-theme-Wikitten.git themes/Wikitten</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">#overwrite default page</span></span></span><br><span class="line">cp -rf themes/Wikitten/_source/* source/</span><br><span class="line">cp -rf themes/Wikitten/_scaffolds/* scaffolds/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">#set profile</span></span></span><br><span class="line">cp -f themes/Wikitten/_config.yml.example themes/Wikitten/_config.yml</span><br><span class="line">vim themes/Wikitten/_config.yml</span><br></pre></td></tr></table></figure><ol start="3"><li>yuque</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YUQUE_TOKEN=&quot;$YUQUE_TOKEN&quot; yuque-hexo sync</span><br></pre></td></tr></table></figure><p>​</p><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;install nodejs npm Git yay&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span
      
    
    </summary>
    
    
      <category term="​" scheme="http://liaozonglong.github.io/tags/%E2%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>布谷鸟问题</title>
    <link href="http://liaozonglong.github.io/wiki/%E5%B8%83%E8%B0%B7%E9%B8%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://liaozonglong.github.io/wiki/布谷鸟问题/</id>
    <published>2022-02-17T07:37:39.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无法截图"><a href="#无法截图" class="headerlink" title="无法截图"></a>无法截图</h2><ol><li>检查计算机名。</li></ol><p>例：用户名为 f’f。即系统环境变量为：C:\Users\f’f.…..<br>解决方法：修改回不带特殊符号的用户名</p><pre><code>     1. 重命名用户文件夹     1. 修改注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Profilelist中的ProfileImagePath的路径地址</code></pre><p>​</p><p>补充<br>布谷鸟临时截图路径<br>C:\Users\计算机用户名\Documents\SisenMESS\用户名\TempFiles\年+月<br>例：C:\Users\Administrator\Documents\SisenMESS\zhangsan\TempFiles\202202<br>​</p><p>​</p><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;无法截图&quot;&gt;&lt;a href=&quot;#无法截图&quot; class=&quot;headerlink&quot; title=&quot;无法截图&quot;&gt;&lt;/a&gt;无法截图&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;检查计算机名。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例：用户名为 f’f。即系统环境变量为：C:\Users\f’f.…
      
    
    </summary>
    
    
      <category term="计算机" scheme="http://liaozonglong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="布谷鸟" scheme="http://liaozonglong.github.io/tags/%E5%B8%83%E8%B0%B7%E9%B8%9F/"/>
    
      <category term="软件" scheme="http://liaozonglong.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://liaozonglong.github.io/wiki/Python/"/>
    <id>http://liaozonglong.github.io/wiki/Python/</id>
    <published>2022-02-07T01:00:25.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程之路"><a href="#编程之路" class="headerlink" title="编程之路"></a>编程之路</h2><p>计算机科学家像数学家一样，使用规范的语言来阐述思想（尤其是一些计算）；像工程师一样设计、组装系统，并且在多重选择中寻找最优解；像自然科学家一样观察复杂系统的行为模式，建立猜想，测试预估的结果。<br>唯一最重要的技能就是『解决问题』。解决问题意味着要有能力把问题进行方程化，创造性地考虑解决思路，并且清晰又精确地表达出解决方案</p><h3 id="程序是什么？"><a href="#程序是什么？" class="headerlink" title="程序是什么？"></a>程序是什么？</h3><p>程序是一个指令的序列，来告诉机器如何进行一组运算。这种运算也许是数学上的，比如求解一组等式或者求多项式的根；当然也可以是符号运算，比如在文档中搜索和替换文字，或者一些图形化过程，比如处理图像或者播放一段视频<br>编程的基础指令：输入系统、输出系统、数学运算、条件判断、重复判断<br>编程的过程理解成一个把庞大复杂任务进行拆分来解决的过程，分解到适合使用上述的基本指令来解决为止。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>“+”、”-“、”*“、”&#x2F;“、”%”</p><h3 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h3><p>type(需要判断的对象) #判断一个值是什么类型</p><hr><h3 id="公示语言和自然语言"><a href="#公示语言和自然语言" class="headerlink" title="公示语言和自然语言"></a>公示语言和自然语言</h3><p>定义：<br>自然语言：就是人说的语言，比如英语、西班牙语、法语，当然包括中文了。他们往往都不是人主动去设计出来的（当然，人会试图去分析语言的规律），自然而然地发生演进。<br>公式语言：人们为了特定用途设计出来的。比如数学的符号就是一种公式语言，特别适合表达数字和符号只见的关系。化学家也用元素符号和化学方程式来表示分子的化学结构。</p><hr><p>语法规则体现在两个方面，代号和结构。<br>公式语言的语法规则是代号必须有严格的组合结构。<br>你读一句英语或者公式语言中的语句时候，你必须搞清楚结构（虽然在自然语言中大家<br>潜意识就能搞定了）。这就叫做解译。<br>两者的差异：二义性、冗余性、文字修辞<br>计算机程序的意义必须是无歧义和文采修饰的，能完全用代号和结构的方式进行解析。</p><hr><h2 id="变量，表达式，语句"><a href="#变量，表达式，语句" class="headerlink" title="变量，表达式，语句"></a>变量，表达式，语句</h2><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>赋值语句的作用是创建一个新的变量，并且赋值给这个变量</p><h3 id="变量名称"><a href="#变量名称" class="headerlink" title="变量名称"></a>变量名称</h3><p>编程的人总得给变量起个有一定意义的名字才能记得住，一般情况就用名字来表示这个变量的用途了<br>不能用数字来开头。大写字母也能用，不过还是建议都用小写字母来给变量命名，这个比较传统哈<br>变量名里面可以有下划线_，一般在多个单词组成的变量名里面往往用到下划线，比如 your_name 等等。</p><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><p>表达式是数值,变量和操作符的组合。单个值本身也被当作一个表达式，变量也是如此<br>语句是一组具有某些效果的代码，比如创建变量，或者显示值。</p><h3 id="脚本模式"><a href="#脚本模式" class="headerlink" title="脚本模式"></a>脚本模式</h3><p>以上我们一直在用 Python 的交互模式，就是直接咱们人跟解释器来交互。开始学的候这样挺好的，但如果你要想一次运行多行代码，这样就很不方便了。<br>所以就有另一种选择了，把代码保存成脚本，然后用脚本模式让解释器来运行这些脚本。通常 Python 脚本文件的扩展名是.py<br>Python 两种模式都支持，所以你可以先用交互模式做点测试，然后再写成脚本。但是两种模式之间有些区别的，所以可能也挺麻烦。</p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>括号&gt;乘方&gt;乘除&gt;加减</p><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>+：字符串拼接 *：字符串重复 n 次</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>使用”#”来开头<br>变量命名得当的话，就没必要用太多注释了，不过名字要是太长了，表达式读起来也挺麻烦，所以就得权衡着来了</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>定义：<br>前置条件：要在函数开始运行之前就要实现才行<br>后置条件：后置条件包含函数的预期效果（如画线段）和其他作用</p><hr><p>语法错误<br>运行错误：显而易见了，就是直到运行的时候才会出现的错误。这种错误也被叫做异常，因为一般表示一些意外的尤其是比较糟糕的情况发生了<br>语义错误：这种错误是指你的程序运行没问题，也不产生错误信息，但不能正确工作。程序可能做一些和设计目的不同的事情。<br>调试也有点像一门实验科学。一旦你有了一个关于所出现的错误的想法，你就修改一下程序再试试看。如果你的假设是正确的，你就能够预料到修改导致的结果，这样在编程的水平上，你就上了一层台阶了，距离让程序工作起来也更近了。<br>​</p><p>前置条件是准备给函数调用者的。如果调用者违背了（妥当标注的）前置条件，然后函数不能正常工作，这个 bug 就会反馈在函数调用者上，而不是函数本身。<br>如果前置条件得到了满足，而后置条件未能满足，这个 bug 就是函数的了。所以如果你的前后置条件都弄清晰，对调试很有帮助。<br>​</p><p>『对折调试』是一种节省调试时间的方法。比如，如果你的程序有 100 行，你检查一遍就要大概 100 步了。而对折方法就是把程序分成两半。看程序中间位置，或者靠近中间位置的，检查一些中间值。在这些位置添加一些 print 语句（或者其他能够能起到验证效果的东西），然后运行程序</p><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>一般来说，函数都要“传入”一个参数，“返回”一个结果。结果也被叫做返回值。Python 提供了一些转换数值类型的函数。</p><h3 id="Math-functions"><a href="#Math-functions" class="headerlink" title="Math functions"></a>Math functions</h3><p>Python 内置了一个数学模块，这一模块提供了绝大部分常用的数学函数。模块就是一系列相关函数的集合成的文件。<br>import math #导入语句</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>一门编程语言最有用的功能莫过于能够用一个个小模块来拼接创作。例如函数的参数可以是任何一种表达式，包括代数运算符：x &#x3D; math.sin(degrees &#x2F; 360.0 _ 2 _ math.pi) ß<br>x &#x3D; math.exp(math.log(x+1)) #函数的调用本身也可以作为参数<br>你可以在任何地方放一个值，放任何一个表达式，只有一个例外：一个声明语句的左边<br>必须是变量名。任何其他的表达式放到等号左边都会导致语法错误（当然也有例外）</p><h3 id="添加新函数"><a href="#添加新函数" class="headerlink" title="添加新函数"></a>添加新函数</h3><p>函数定义要指定这个心函数的名字，还需要一系列语句放到这个函数里面，当调用这个函数的时候，就会运行这些语句了。<br>​</p><p>def 函数名(): &lt;–头部<br>执行语句… &lt;–函数体<br>​</p><p>如果你在交互模式下面定义函数，解释器会显示三个小点来提醒你定义还没有完成</p><h3 id="定义并使用"><a href="#定义并使用" class="headerlink" title="定义并使用"></a>定义并使用</h3><p>函数名()</p><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>一个 Python 程序都是从第一个语句开始运行的。从首至尾，每次运行一个语句。<br>函数的定义并不会改变程序的运行流程，但要注意，函数体内部的语句只有在函数被调用的时候才会运行。<br>总的来说，你阅读一个程序的时候，并不一定总是要从头到尾来读的。有时候你要按照运行流程来读才更好理解。</p><h3 id="形式参数和实际参数"><a href="#形式参数和实际参数" class="headerlink" title="形式参数和实际参数"></a>形式参数和实际参数</h3><p>在函数里面，实际参数会被赋值给形式参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_twice</span>(<span class="params">bruce</span>):</span><br><span class="line"><span class="built_in">print</span>(bruce)</span><br><span class="line"><span class="built_in">print</span>(bruce)</span><br><span class="line">这个函数把传来的实际参数的值赋给了一个名字叫做burce的形式参数</span><br></pre></td></tr></table></figure><p>适用于 Python 内置函数的组合规则对自定义的函数也是适用的，所以我们可以把表达式作为实际参数<br>传递参数的时候用的是实际参数，是把这个实际参数的值交给调用的函数，函数内部接收这个值，可以命名成任意其他名字的形式参数</p><h3 id="函数内部变量和形参都是局部的"><a href="#函数内部变量和形参都是局部的" class="headerlink" title="函数内部变量和形参都是局部的"></a>函数内部变量和形参都是局部的</h3><p>在函数内部建立一个变量，这个变量是仅在函数体内部才存在<br>形式参数也是局部起作用的。例如在 print_twice 这个函数之外，是不存在 bruce 这个变量的。</p><h3 id="栈图"><a href="#栈图" class="headerlink" title="栈图"></a>栈图</h3><p>要追踪一个变量能在哪些位置使用，咱们就可以画个图表来实现，这种图表叫做栈图。栈图和我们之前提到的状态图有些相似，也会表征每个变量的值，不同的是栈图还会标识出每个变量所属的函数。<br>每个函数都用一个框架来表示。框架的边上要标明函数的名字，框内填写函数内部的形参和变量。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1645161244642-4bae0ecd-df05-4786-8e86-b9db1b622eed.png#clientId=u2d41eee7-79ed-4&crop=0&crop=0&crop=1&crop=1&id=WzJm1&name=image.png&originHeight=161&originWidth=308&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=24697&status=done&style=none&taskId=ud398bc96-5bbb-4c1f-b480-8a94125f648&title=" alt="image.png"><br>如果函数调用的时候出错了，Python 会打印出这个出错函数的名字，调用这个出错函数的函数名，以及调用这个调用了出错函数的函数的函数名，一直追溯到主函数<br>这个一系列的函数列表，就是一个追溯了。这回告诉你哪个程序文件出了错误，哪一行出了错误，以及当时哪些函数在运行。还会告诉你引起错误的代码所在行号。</p><h3 id="有返回值的函数-和-无返回值的函数"><a href="#有返回值的函数-和-无返回值的函数" class="headerlink" title="有返回值的函数 和 无返回值的函数"></a>有返回值的函数 和 无返回值的函数</h3><p>定义：<br>有返回值的函数：比如数学的函数，都会返回各种结果<br>无返回值的函数：比如 print_twice，都是进行一些操作，但不返回值</p><hr><p>如果是脚本模式，你运行一个有返回值的函数，但没有利用这个返回值，这个返回值就会永远丢失了！（译者注：只要有返回值就一定要利用！）</p><hr><h3 id="为什么要用函数？"><a href="#为什么要用函数？" class="headerlink" title="为什么要用函数？"></a>为什么要用函数？</h3><ol><li>创建一个新的函数，你就可以把一组语句用一个名字来命名，这样你的程序读起来就清晰多了，后期维护调试也方便</li><li>函数的出现能够避免代码冗余，程序内的一些重复的内容就会简化了，变得更小巧。而且在后期进行修改的时候，你只要改函数中的一处地方就可以了，很方便</li><li>把长的程序切分成一个个函数，你就可以一步步来 debug 调试，每次只应对一小部分就可以，然后把它们组合起来就可以用了</li><li>精细设计的函数会对很多程序都有用处。一旦你写好了并且除了错，这种函数代码可以再利用</li></ol><h2 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h2><h3 id="开发计划"><a href="#开发计划" class="headerlink" title="开发计划"></a>开发计划</h3><p>定义：<br>泛化：给函数添加参数，就叫做泛化，因为者可以让函数的功能更广泛</p><hr><p>开发计划是写程序的一系列过程。我们本章所用的就是『封装-泛化』的模式。这一过程的步骤如下：</p><ol><li>开始写一个特别小的程序，没有函数定义。</li><li>一旦有你的程序能用了，确定一下实现功能的这部分有练习的语句，封装成函数，并命名一下。</li><li>通过逐步给这个函数增加参数的方式来泛化。</li><li>重复 1-3 步骤，一直到你有了一系列能工作的函数为止。把函数复制粘贴出来，避免重复输入或者修改了。</li><li>看看是不是有通过重构来改进函数的可能。比如，假设你在一些地方看到了相似的代码，就可以把这部分代码做成一个函数。</li></ol><hr><h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h3><p>文档字符串是指：在函数开头部位，解释函数的交互界面的字符串，doc 是文档<br>documentation 的缩写。下面是一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">polyline</span>(<span class="params">t, n, length, angle</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Draws n line segments with the given length and angle (in degrees) between them.</span></span><br><span class="line"><span class="string">t is a turtle. &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">t.fd(length)</span><br><span class="line">t.lt(angle)</span><br></pre></td></tr></table></figure><h2 id="条件循环"><a href="#条件循环" class="headerlink" title="条件循环"></a>条件循环</h2><h3 id="地板除和求模"><a href="#地板除和求模" class="headerlink" title="地板除和求模"></a>地板除和求模</h3><p>floor 除法（地板除法）——运算符”&#x2F;&#x2F;“：地板除法会把运算结果的小数位舍弃，返回整值<br>求模——运算符”%”：会把两个数相除然后返回余数。</p><h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h3><p>运算符”&#x3D;&#x3D;”：一种非对即错的表达式，仅有 true（真）或者 false（假）</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符有三种：且，或以及非<br>且：比如 x&gt;0 且 x&lt;10<br>或：<br>非：非运算，是针对布尔表达式的，非（x&gt;y）为真，那么 x&gt;y 就是假的，意味着 x 小于等于 y。</p><h3 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h3><p>if 后面的布尔表达式就叫做条件。如果条件为真，随后缩进的语句就运行。如果条件为假，就不运行<br>复合语句中语句体内的语句数量是不限制的，但至少要有一个。有的时候会遇到一个语句体内不放语句的情况，比如空出来用来后续补充。这种情况下，你就可以用 pass 语句，就是啥也不会做的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="选择执行"><a href="#选择执行" class="headerlink" title="选择执行"></a>选择执行</h3><p>if 语句的第二种形式就是『选择执行』，这种情况下会存在两种备选的语句，根据条件来判断执行哪一个。语法如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x is even&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x is odd&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="链式条件"><a href="#链式条件" class="headerlink" title="链式条件"></a>链式条件</h3><p>有时我们要面对的可能性不只有两种，需要更多的分支。这时候可以使用连锁条件来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; y:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x is less than y&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> x &gt; y:<span class="comment">#elif是『else if』的缩写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x is greater than y&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:<span class="comment">#else语句必须放到整个条件链；不过else语句并不是必须有的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x and y are equal&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="嵌套条件"><a href="#嵌套条件" class="headerlink" title="嵌套条件"></a>嵌套条件</h3><p>一个条件判断也可以嵌套在另一个条件判断内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x and y are equal&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> x &lt; y:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;x is less than y&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;x is greater than y&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="递归运算"><a href="#递归运算" class="headerlink" title="递归运算"></a>递归运算</h3><p>一个函数可以去调用另一个函数；函数来调用自己也是允许的。这就是递归;执行这种函数的过程就叫递归运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Blastoff!&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">        countdown(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="递归函数的栈图"><a href="#递归函数的栈图" class="headerlink" title="递归函数的栈图"></a>递归函数的栈图</h3><p>每次有一个函数被调用的时候，Python 都会创建一个框架来包含这个函数的局部变量和形式参数。对于递归函数来说，可能会在栈中同时生成多层次的框架。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1645161244575-33802a22-6390-4b69-b7cb-7ec7a4b98117.png#clientId=u2d41eee7-79ed-4&crop=0&crop=0&crop=1&crop=1&id=pDeKn&name=image.png&originHeight=171&originWidth=154&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12570&status=done&style=none&taskId=uc1ab1220-8427-4f30-9a1e-7b9cbc8660e&title=" alt="image.png"></p><h3 id="无穷递归"><a href="#无穷递归" class="headerlink" title="无穷递归"></a>无穷递归</h3><p>如果一个递归一直都不能到达基准条件，那就会持续不断地进行自我调用，程序也就永远不会终止了。这就叫无穷递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recurse</span>():</span><br><span class="line">    recurse()</span><br></pre></td></tr></table></figure><h3 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h3><p>内置的一个函数”input”函数这个函数会停止程序运行，等待用户来输入一些内容。用户按下 ESC 或者 Enter 回车键，程序就恢复运行，input 函数就把用户输入的内容作为字符串返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;What...is your name?\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h2><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>对函数进行调用，就会产生一个返回的值，我们一般把这个值赋给某个变量，或者放进表达式中来用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">radius</span>):</span><br><span class="line">    a = math.pi * radius**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>有一些临时变量可以让后续的调试过程更简单。所以有时候可以多设置几条返回语句，每一条都对应一种情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">absolute_value</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>返回语句运行的时候，函数就结束了，也不会运行任何其他的语句了。返回语句后面的代码，执行流程里所有其他的位置都无法再触碰了，这种代码叫做『死亡代码』</p><h3 id="增量式开发"><a href="#增量式开发" class="headerlink" title="增量式开发"></a>增量式开发</h3><p>要应对越来越复杂的程序，你不妨来试试增量式开发的办法。增量式开发的目的是避免长时间的调试过程，一点点对已有的小规模代码进行增补和测试<br>​</p><p>这个函数只需要返回一个值。我们写得这些 print 打印语句都是用来调试的，但一旦程序能正常工作了，就应该把 print 语句去掉。这些 print 代码也叫『脚手架代码』因为是用来构建程序的，但不会被存放在最终版本的程序中<br>​</p><p>这个过程的核心如下：</p><ol><li>一定要用一个能工作的程序来开始，每次逐渐添加一些细小增补。在任何时候遇到错误，都应该弄明白错误的位置。</li><li>用一些变量来存储中间值，这样你可以显示一下这些值，来检查一下。</li><li>程序一旦能工作了，你就应该把一些发挥『脚手架作用』的代码删掉，并且把重复的语句改写成精简版本，但尽量别让程序变得难以阅读。</li></ol><h3 id="布尔函数"><a href="#布尔函数" class="headerlink" title="布尔函数"></a>布尔函数</h3><p>函数也可以返回布尔值，这种情况便于隐藏函数内部的复杂测试。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_divisible</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> x % y == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><h3 id="再赋值"><a href="#再赋值" class="headerlink" title="再赋值"></a>再赋值</h3><p>对同一个变量可以多次进行赋值。一次新的赋值使得已有的变量获得新的值<br>对变量进行再赋值总是很有用的，但你用的时候要做好备注和提示。如果变量的值频繁变化，就可能让代码难以阅读和调试</p><h3 id="更新变量"><a href="#更新变量" class="headerlink" title="更新变量"></a>更新变量</h3><p>这种情况下新的值是在旧值基础上进行修改得到的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="循环：While-语句"><a href="#循环：While-语句" class="headerlink" title="循环：While 语句"></a>循环：While 语句</h3><p>在一个计算机程序里面，重复操作也被叫做迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Blastoff!&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = <span class="built_in">input</span>(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> line == <span class="string">&#x27;done&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span><span class="comment">#中断语句&quot;break&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Done!&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="平方根"><a href="#平方根" class="headerlink" title="平方根"></a>平方根</h3><p>循环经常被用于进行数值运算的程序中，这种程序往往是有一个近似值作为初始值，然后逐渐迭代去改进以接近真实值。<br>​</p><p>通过对比两个数字之间是否相当，可以判断是否接近了真实值。但是这个如果用在浮点型上就会有很大的问题。相比之下，与其对比 x 和 y 是否精确相等，倒不如以下方法更安全：用内置的绝对值函数来计算一下差值的绝对值，也叫做数量级。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">abs</span>(y-x) &lt; epsilon:</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>比如找到一个 n 与 9 的成绩，你可以把 n-1 写成第一位，10-n 携程第二位。这个技巧是应对任何个位数字乘以 9 的算式。这就是一个算法了！<br>执行算法是很无聊的，但设计算法很有趣，是智力上的一种挑战，也是计算机科学的核心部分</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>一个字符串是一个序列，意味着是对其他值的有序排列</p><h3 id="字符串是字符"><a href="#字符串是字符" class="headerlink" title="字符串是字符"></a>字符串是字符</h3><p>字符串就是一串有序的字符。你可以通过方括号操作符，每次去访问字符串中的一个字<br>符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fruit = <span class="string">&#x27;banana&#x27;</span></span><br><span class="line">letter = fruit[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="len-长度"><a href="#len-长度" class="headerlink" title="len 长度"></a>len 长度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fruit = <span class="string">&#x27;banana&#x27;</span></span><br><span class="line"><span class="built_in">len</span>(fruit)</span><br></pre></td></tr></table></figure><h3 id="用-for-循环进行遍历"><a href="#用-for-循环进行遍历" class="headerlink" title="用 for 循环进行遍历"></a>用 for 循环进行遍历</h3><p>很多计算过程都需要每次从一个字符串中拿一个字符。一般都是从头开始，依次得到每个字符，然后做点处理，然后一直到末尾。这种处理模式叫遍历。写一个遍历可以使用 while 循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="built_in">len</span>(fruit):</span><br><span class="line">    letter = fruit[index]</span><br><span class="line">    <span class="built_in">print</span>(letter)</span><br><span class="line">    index = index + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>另外一种遍历的方法就是 for 循环了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> fruit:</span><br><span class="line"><span class="built_in">print</span>(letter)</span><br></pre></td></tr></table></figure><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[n:m]</span><br><span class="line">x[:]<span class="comment">#全部输出</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1645161244669-05804564-35a4-4e35-bb55-19960b84a01f.png#clientId=u2d41eee7-79ed-4&crop=0&crop=0&crop=1&crop=1&id=Gkee4&name=image.png&originHeight=61&originWidth=220&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=6883&status=done&style=none&taskId=u9e5e3581-81d8-4277-9c1e-e96ba4b8d37&title=" alt="image.png"></p><h3 id="字符串不可修改"><a href="#字符串不可修改" class="headerlink" title="字符串不可修改"></a>字符串不可修改</h3><p>你不能对一个已经存在的字符串进行任何改动。你顶多也就能建立一个新字符串，新字符串可以基于旧字符串进行一些改动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greeting = <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">new_greeting = <span class="string">&#x27;J&#x27;</span> + greeting[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p>运算符 in<br>in 这个词在字符串操作中是一个布尔操作符，它读取两个字符串，如果前者的字符串为后者所包含，就返回真，否则为假：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;banana&#x27;</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Python 里面最有用的一种内置类型：列表。</p><h3 id="列表即序列"><a href="#列表即序列" class="headerlink" title="列表即序列"></a>列表即序列</h3><p>和字符串差不多，列表是一系列的数值的序列。在字符串里面，这些值是字符；在列表里面，这些值可以是任意类型的。一个列表中的值一般叫做列表的元素，有时候也叫列表项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">[<span class="string">&#x27;crunchy frog&#x27;</span>, <span class="string">&#x27;ram bladder&#x27;</span>, <span class="string">&#x27;lark vomit&#x27;</span>]</span><br></pre></td></tr></table></figure><p>列表内部可以包含一个列表作为元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;spam&#x27;</span>, <span class="number">2.0</span>, <span class="number">5</span>, [<span class="number">10</span>, <span class="number">20</span>]]</span><br></pre></td></tr></table></figure><h3 id="列表元素可修改"><a href="#列表元素可修改" class="headerlink" title="列表元素可修改"></a>列表元素可修改</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cheeses[<span class="number">0</span>]<span class="comment">#方括号内的数字用来确定索引位置</span></span><br></pre></td></tr></table></figure><p>修改列表的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">42</span>, <span class="number">123</span>]</span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="遍历一个列表"><a href="#遍历一个列表" class="headerlink" title="遍历一个列表"></a>遍历一个列表</h3><p>最常用的办法就是 for 循环了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> cheese <span class="keyword">in</span> cheeses:</span><br><span class="line">    <span class="built_in">print</span>(cheese)</span><br></pre></td></tr></table></figure><h3 id="列表运算符"><a href="#列表运算符" class="headerlink" title="列表运算符"></a>列表运算符</h3><p>加号+运算符可以把列表拼接在一起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">c = a + b</span><br></pre></td></tr></table></figure><p>星号*运算符可以将列表重复指定的次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]</span><br><span class="line">t[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="列表的方法"><a href="#列表的方法" class="headerlink" title="列表的方法"></a>列表的方法</h3><p>append 就可以在列表末尾添加一个新的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">t.append(<span class="string">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure><p>extend 使用另一个列表做参数，然后把所有的元素添加到一个列表上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">t2 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">t1.extend(t2)</span><br></pre></td></tr></table></figure><p>sort 把列表中的元素从低到高（译者注：下面的例子中是按照 ASCII 码的大小从小到大）排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">t.sort()</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>从一个列表中删除元素有几种方法。如果你知道你要删除元素的索引，你就可以用 pop 这个方法来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = a.pop(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>如果你不需要删掉的值了，你可以用 del 运算符来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[<span class="number">1</span>]<span class="comment">#可切片：del a[1:5]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>如果你知道你要删除的元素值，但不知道索引位置，你可以使用 remove 这个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.remove(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="列表和字符串"><a href="#列表和字符串" class="headerlink" title="列表和字符串"></a>列表和字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">join：将字符串转换成一个个元素，并转变成列表</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;test-and-test&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&#x27;-&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = s.split(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">[<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;and&#x27;</span>,<span class="string">&#x27;test&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">solit：将列表的元素转变成字符串</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;and&#x27;</span>,<span class="string">&#x27;test&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = b.join(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="string">&#x27;test and test&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="对象和值"><a href="#对象和值" class="headerlink" title="对象和值"></a>对象和值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span><span class="comment">#结果为真，即两个变量指向的是同一个对象。如果你创建的是一个列表，那么就是两个对象，结果即False</span></span><br></pre></td></tr></table></figure><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a<span class="comment">#修改其中任何一个的值，也会导致另外一个值一起变化</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="字典是一种映射"><a href="#字典是一种映射" class="headerlink" title="字典是一种映射"></a>字典是一种映射</h3><p>列表概念的推广。在列表里面，索引必须是整数；而在字典里面，你可以用几乎任何类型来做索引了<br>​</p><p>字典包括一系列的索引，不过就已经不叫索引了，而是叫键，然后还对应着一个个值，就叫键值。每个键对应着各自的一个单独的键值。这种键和键值的对应关系也叫键值对，有时候也叫项<br>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test = &#123;one: <span class="string">&quot;test&quot;</span>&#125;<span class="comment">#创建新字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;one&#x27;</span> <span class="keyword">in</span> test<span class="comment">#判断该字典是否存在one键</span></span><br></pre></td></tr></table></figure><h3 id="循环与字典"><a href="#循环与字典" class="headerlink" title="循环与字典"></a>循环与字典</h3><p>如果你在 for 语句里面用字典，程序会遍历字典中的所有键。</p><h3 id="逆向查找"><a href="#逆向查找" class="headerlink" title="逆向查找"></a>逆向查找</h3><p>给定一个字典 d，以及一个键 k，很容易找到对应的键值 v&#x3D;d[k]。这个操作就叫查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_lookup</span>(<span class="params">d, v</span>):</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">        <span class="keyword">if</span> d[k] == v:</span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">    <span class="keyword">raise</span> LookupError()</span><br><span class="line">    没有一种简单的语法能实现这样一种逆向查找；你必须搜索一下</span><br></pre></td></tr></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在主函数中的变量也叫全局变量，因为所有函数都可以访问这些变量。局部变量在所属的函数结束后就消失了，而主函数在其他函数调用结束后依然还存在<br>一般常用全局变量作为 flag，也就是标识<br>​</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><h3 id="元组不可修改"><a href="#元组不可修改" class="headerlink" title="元组不可修改"></a>元组不可修改</h3><p>元组是一系列的值。这些值可以是任意类型的，并且用整数序号作为索引，所以可以发现元组和列表非常相似。二者间重要的区别就是元组是不可修改的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="comment">#元组的语法是一系列用逗号分隔的值，通常都用一对圆括号把元组的元素包括起来，当然不这样也没事</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = <span class="string">&#x27;a&#x27;</span>,<span class="comment">#要建立一个单个元素构成的元组，必须要在结尾加上逗号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">&#x27;A&#x27;</span>,) + t[<span class="number">1</span>:]<span class="comment">#元组是不能修改的，你不能修改其中的元素。但是可以用另一个元组来替换已有的</span></span><br><span class="line">元组——该语句建立了一个新的元组</span><br></pre></td></tr></table></figure><h3 id="元组赋值"><a href="#元组赋值" class="headerlink" title="元组赋值"></a>元组赋值</h3><p>对两个变量的值进行交换是一种常用操作。用常见语句来实现的话，就必须有一个临时变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = temp</span><br><span class="line"><span class="comment">#上一段语句可以转换成下面条语句</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = b, a</span><br></pre></td></tr></table></figure><h3 id="用元组做返回值"><a href="#用元组做返回值" class="headerlink" title="用元组做返回值"></a>用元组做返回值</h3><p>严格来说，一个函数只能返回一个值，但如果这个值是一个元组，效果就和返回多个值一样了<br>将结果存储为一个元组，然后使用元组复制分别调用<br>​</p><h3 id="参数长度可变的元组"><a href="#参数长度可变的元组" class="headerlink" title="参数长度可变的元组"></a>参数长度可变的元组</h3><p>函数的参数可以有任意多个。用星号*开头来作为形式参数名，可以将所有实际参数收录到一个元组中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printall</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">printall(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h3><p>zip 是一个内置函数，接收两个或更多的序列作为参数，然后返回返回一个元组列表，该列表中每个元组都包含了从各个序列中的一个元素。<br>​</p><h3 id="词典与元组"><a href="#词典与元组" class="headerlink" title="词典与元组"></a>词典与元组</h3><p>字典有一个名为 items 的方法，会返回一个由元组组成的序列，每一个元组都是字典中的一个键值对<br>​</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>『持久的』程序，就是把数据进行永久存储</p><h3 id="持久"><a href="#持久" class="headerlink" title="持久"></a>持久</h3><p>程序持久的特征：它们运行时间很长（甚至一直在运行）；这些程序还会至少永久保存一部分数据（比如存在硬盘上等等）；然后如果程序关闭了或者重新始了，也能从之前停留的状态继续工作。——例如：操作系统<br>​</p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>open 函数会返回一个文件对象，文件对象会提供各种方法来处理文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这样用写入的模式来打开，会把旧的文件都清除掉，然后重新写入文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fout = <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write 这个方法就把数据写入到文件中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>line1 = <span class="string">&quot;This here&#x27;s the wattle,\n&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fout.write(line1)</span><br></pre></td></tr></table></figure><h3 id="文件名与路径"><a href="#文件名与路径" class="headerlink" title="文件名与路径"></a>文件名与路径</h3><p>文件都是按照目录（也叫文件夹）来组织存放的。每一个运行着的程序都有一个当前目录，也就是用来处理绝大多数运算和操作的默认目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cwd = os.getcwd()<span class="comment">#获取当前工作目录</span></span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>该模块可以把几乎所有类型的对象翻译成字符串模式，以便存储在数据库中，然后用的时候还可以把字符串再翻译回来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dumps(t)</span><br><span class="line"><span class="string">b&#x27;\x80\x03]q\x00(K\x01K\x02K\x03e.&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="编写模块"><a href="#编写模块" class="headerlink" title="编写模块"></a>编写模块</h3><p>以模块方式导入使用的程序一般用下面这样的惯用形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(linecount(<span class="string">&#x27;wc.py&#x27;</span>))</span><br></pre></td></tr></table></figure><p><strong>name</strong> 是一个内置变量，当程序开始运行的时候被设置。如果程序是作为脚本来运行的，<strong>name</strong> 的值就是’<strong>main</strong>‘；这样的话，if 条件满足，测试代码就会运行而如果该代码被用作模块导入了，if 条件不满足，测试的代码就不会运行了<br>​</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="用户自定义类型"><a href="#用户自定义类型" class="headerlink" title="用户自定义类型"></a>用户自定义类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;Represents a point in 2-D space.&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#头部代码的意思是表示新建的类名字叫 Point。然后类的体内有一个文档字符串，解释类的用途。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Point&#x27;</span>&gt;</span><br><span class="line"><span class="comment">#因为 Point 是在顶层位置定义的，所以全名就是__main__.Point</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>blank = Point()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>blank</span><br><span class="line">&lt;__main__.Point <span class="built_in">object</span> at <span class="number">0xb7e9d3ac</span>&gt;</span><br><span class="line"><span class="comment">#类的对象就像是一个创建对象的工厂。要创建一个 Point，就可以像调用函数一样调用Point。</span></span><br><span class="line"><span class="comment">#创建一个新的对象也叫做实例化，这个对象就是类的一个实例</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blank.x = <span class="number">3.0</span><span class="comment">#用点号可以给实例进行赋值——不管该实例内是否存在该变量名的初始化</span></span><br><span class="line">x = blank.x<span class="comment">#赋值</span></span><br><span class="line"><span class="built_in">print</span>(blank.x)<span class="comment">#直接打印</span></span><br></pre></td></tr></table></figure><p>一个类去作为另外一个类的属性，就叫做嵌入<br>​</p><h3 id="对象可以修改"><a href="#对象可以修改" class="headerlink" title="对象可以修改"></a>对象可以修改</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">box.width = box.width + <span class="number">50</span></span><br><span class="line">box.height = box.height + <span class="number">100</span></span><br><span class="line"></span><br><span class="line">你还可以写专门的函数来修改对象</span><br></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>浅复制：复制一个对象中除了内嵌对象之外的所有引用；通过 copy 模块的 copy 函数来实现。<br>深复制：复制一个对象的所有内容，包括内嵌对象，以及内嵌对象中的所有内嵌对象等等；通过 copy 模块的 deepcopy 函数来实现。<br>​</p><p>别名有可能让程序读起来有困难，因为在一个位置做出的修改有可能导致另外一个位置发生不可预知的情况。这样也很难去追踪指向一个对象的所有变量<br>​</p><p>copy 模块包含了一个名叫 copy 的函数，可以复制任意对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = Point()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.x = <span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.y = <span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2 = copy.copy(p1)</span><br><span class="line"></span><br><span class="line"><span class="comment">##p1跟p2数据相同，但不是同一个对象</span></span><br></pre></td></tr></table></figure><h2 id="类和函数"><a href="#类和函数" class="headerlink" title="类和函数"></a>类和函数</h2><p>纯函数，这种函数并不修改传来做参数的对象，也没有什么效果，比如显示值啊或者让用户输入啊等等，而只是返回一个值而已。<br>​</p><h3 id="原型与规划"><a href="#原型与规划" class="headerlink" title="原型与规划"></a>原型与规划</h3><p>原型与补丁模式：一种开发模式，先写一个程序的草稿，然后测试，再改正发现的错误，这样逐步演化的开发模式<br>这种模式很有效率，尤其是在你对问题的理解不是很深入的时候。不过渐进式的修改也会产生过分复杂的代码——因为要应对很多特例情况，而且也不太靠靠——因为好确定你是否找到了所有的错误。<br>​</p><p>设计规划开发：这种开发模式要求对所面对问题的高程度的深刻理解，相比渐进式开发和原型增补模式要更具有计划性<br>​</p><h2 id="类和方法"><a href="#类和方法" class="headerlink" title="类和方法"></a>类和方法</h2><p>对象往往代表着现实世界中的事物，方法则相对应地代表着现实世界中事物之间的相互作用</p><h3 id="面向对象的特性"><a href="#面向对象的特性" class="headerlink" title="面向对象的特性"></a>面向对象的特性</h3><p>Python 是一种面向对象的编程语言，这就意味着它提供了一些支持面向对象编程的功能，有以下这些特点：</p><ol><li>程序包含类和方法的定义。</li><li>大多数运算都以对象运算的形式来实现。</li></ol><p>​</p><h3 id="init-方法"><a href="#init-方法" class="headerlink" title="init 方法"></a>init 方法</h3><p>在对象被实例化的时候被调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># inside class Time:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span></span>):</span><br><span class="line">    self.hour = hour</span><br><span class="line">    self.minute = minute</span><br><span class="line">    self.second = second</span><br></pre></td></tr></table></figure><h3 id="str-方法"><a href="#str-方法" class="headerlink" title="str 方法"></a>str 方法</h3><p><strong>str</strong> 是一种特殊的方法，就跟<strong>init</strong>差不多，str 方法是接收一个对象，返回一个代表该对象的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># inside class Time:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;%.2d:%.2d:%.2d&#x27;</span> % (self.hour, self.minute, self.second)</span><br></pre></td></tr></table></figure><p>写一个新的类的时候，总要先写出来 <strong>init</strong> 方法，这样有利于简化对象的初始化，还要写个 <strong>str</strong> 方法，这个方法在调试的时候很有用<br>​</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载：像+加号这样的运算符，在处理用户自定义类型的时候改变为相应的运算<br>​</p><h3 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h3><p>面向对象编程设计的目的之一就是让软件更容易维护，这就意味着当系统中其他部分发生改变的时候依然能让程序运行，然后可以修改程序去符合新的需求。<br>实现这一目标的程序设计原则就是要让接口和实现分开。对于对象来说，这就意着一个类包含的方法要不能被属性表达方式的变化所影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编程之路&quot;&gt;&lt;a href=&quot;#编程之路&quot; class=&quot;headerlink&quot; title=&quot;编程之路&quot;&gt;&lt;/a&gt;编程之路&lt;/h2&gt;&lt;p&gt;计算机科学家像数学家一样，使用规范的语言来阐述思想（尤其是一些计算）；像工程师一样设计、组装系统，并且在多重选择中寻找最优解
      
    
    </summary>
    
    
      <category term="计算机" scheme="http://liaozonglong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="计算机语言" scheme="http://liaozonglong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://liaozonglong.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://liaozonglong.github.io/wiki/MySQL/"/>
    <id>http://liaozonglong.github.io/wiki/MySQL/</id>
    <published>2022-01-27T01:41:54.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装以及配置"><a href="#安装以及配置" class="headerlink" title="安装以及配置"></a>安装以及配置</h2><hr><h3 id="ubuntu-下安装"><a href="#ubuntu-下安装" class="headerlink" title="ubuntu 下安装"></a>ubuntu 下安装</h3><p>sudo apt-get install mysql-client mysql-server</p><h3 id="卸载-MySQL"><a href="#卸载-MySQL" class="headerlink" title="卸载 MySQL"></a>卸载 MySQL</h3><p>查看 mysql：dpkg –list |grep mysql<br>删除 mysql：sudo apt-get remove mysql-*<br>清理残留的数据 ：dpkg -l |grep ^rc|awk ‘{print $2}’ |sudo xargs dpkg -P</p><hr><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><h4 id="开放远程访问"><a href="#开放远程访问" class="headerlink" title="开放远程访问"></a>开放远程访问</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">配置/etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br><span class="line">!includedir /etc/mysql/mysql.conf.d/</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line">port=<span class="number">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="comment"># basedir=/usr/local/mysql</span></span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="comment"># datadir= /var/lib/mysql</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line">max_connections=<span class="number">200</span></span><br><span class="line"><span class="comment"># 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span></span><br><span class="line">max_connect_errors=<span class="number">10</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为UTF8</span></span><br><span class="line">character-<span class="built_in">set</span>-server=utf8mb4</span><br><span class="line"><span class="comment">#使用–skip-external-locking MySQL选项以避免外部锁定。该选项默认开启</span></span><br><span class="line">external-locking = FALSE</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=error.log</span><br><span class="line"><span class="comment">#pid-file=mysqld.pid</span></span><br><span class="line"><span class="comment"># 定义mysql应该支持的sql语法，数据校验</span></span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">[mysql]</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-<span class="built_in">set</span>=utf8mb4</span><br><span class="line">[client]</span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line">port=<span class="number">3306</span></span><br><span class="line">default-character-<span class="built_in">set</span>=utf8mb4</span><br></pre></td></tr></table></figure><p>[</p><p>](<a href="https://www.cnblogs.com/zhongyehai/p/10695659.html">https://www.cnblogs.com/zhongyehai/p/10695659.html</a>)</p><h4 id="默认密码所在位置"><a href="#默认密码所在位置" class="headerlink" title="默认密码所在位置"></a>默认密码所在位置</h4><p>Ubuntu18.04 安装过程中没有设置密码的环节(如果有就下面的不需要做了)<br>sudo cat &#x2F;etc&#x2F;mysql&#x2F;debian.cnf<br><img src="https://s2.loli.net/2022/01/29/gBEhdlZ5Nb4LSkx.png#crop=0&crop=0&crop=1&crop=1&id=D9HDC&originHeight=105&originWidth=299&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p><hr><h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><p>service mysql restart #重启</p><hr><h2 id="基础语句"><a href="#基础语句" class="headerlink" title="基础语句"></a>基础语句</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><hr><p><strong>创建\删除\查看\修改</strong><br>use mysql; #进入 mysql 数据库</p><p>CREATE USER ‘username‘@’host’ IDENTIFIED BY ‘password’; #创建用户</p><p>drop user root; #删除用户</p><p>select host, user, authentication_string from mysql.user; #查看用户登陆主机\用户名\密码(不同版本 mysql 语句有出入)</p><p>SET PASSWORD FOR ‘username‘@’host’ &#x3D; PASSWORD(‘newpassword’); #设置与更改用户密码<br>​</p><p>flush privileges; #刷新系统权限表</p><hr><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用户授权</span><br><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> databasename.tablename <span class="keyword">TO</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span> #授权语句规则</span><br><span class="line">格式：<span class="keyword">grant</span> 权限 <span class="keyword">on</span> 数据库.<span class="operator">*</span> <span class="keyword">to</span> 用户名@登录主机 identified <span class="keyword">by</span> &quot;密码&quot;;　</span><br><span class="line">说明:</span><br><span class="line">privileges：用户的操作权限，如<span class="keyword">SELECT</span>，<span class="keyword">INSERT</span>，<span class="keyword">UPDATE</span>等，如果要授予所的权限则使用<span class="keyword">ALL</span></span><br><span class="line">databasename：数据库名</span><br><span class="line">tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<span class="operator">*</span>表示，如<span class="operator">*</span>.<span class="operator">*</span></span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> tornado.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;haidon&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>revoke all on tornado.* from “haidon”@”%”; #收回用户权限<br>​</p><hr><h3 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h3><p><strong>创建\删除\查看\修改</strong><br>create database 数据库名; #创建数据库<br>create database article character set utf8; #创建并设置 utf8 格式</p><p>drop database &lt;数据库名&gt;; #删除数据库<br>​</p><p>show databses; #查看所有数据库</p><hr><h3 id="表管理"><a href="#表管理" class="headerlink" title="表管理"></a>表管理</h3><p>select * from tb_info; #查看指定的表的现有数据</p><p>desc 表名; #查看指定表结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">写入数据</span><br><span class="line">INSERT INTO table_name ( field1, field2,...fieldN )</span><br><span class="line">                        VALUES</span><br><span class="line">                        ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装以及配置&quot;&gt;&lt;a href=&quot;#安装以及配置&quot; class=&quot;headerlink&quot; title=&quot;安装以及配置&quot;&gt;&lt;/a&gt;安装以及配置&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;ubuntu-下安装&quot;&gt;&lt;a href=&quot;#ubuntu-下安装&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="服务" scheme="http://liaozonglong.github.io/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="计算机" scheme="http://liaozonglong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="MySQL" scheme="http://liaozonglong.github.io/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://liaozonglong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>python连接MySQL</title>
    <link href="http://liaozonglong.github.io/wiki/python%E8%BF%9E%E6%8E%A5MySQL/"/>
    <id>http://liaozonglong.github.io/wiki/python连接MySQL/</id>
    <published>2022-01-27T01:29:16.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<p>python 连接 MySQL</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开数据库连接</span></span><br><span class="line">db = MySQLdb.connect(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;testuser&quot;</span>, <span class="string">&quot;test123&quot;</span>, <span class="string">&quot;TESTDB&quot;</span>, charset=<span class="string">&#x27;utf8&#x27;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用execute方法执行SQL语句</span></span><br><span class="line">cursor.execute(<span class="string">&quot;SELECT VERSION()&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 fetchone() 方法获取一条数据</span></span><br><span class="line">data = cursor.fetchone()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Database version : %s &quot;</span> % data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库连接</span></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python 连接 MySQL&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
    
      <category term="计算机" scheme="http://liaozonglong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="计算机语言" scheme="http://liaozonglong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据库" scheme="http://liaozonglong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Python" scheme="http://liaozonglong.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>PPTPD</title>
    <link href="http://liaozonglong.github.io/wiki/Pptpd/"/>
    <id>http://liaozonglong.github.io/wiki/Pptpd/</id>
    <published>2022-01-26T09:30:18.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<p><strong>安装 PPTP</strong><br>sudo apt-get update<br>sudo apt-get install pptpd<br><strong>配置 PPTP</strong><br>sudo vim &#x2F;etc&#x2F;pptpd.conf——取消掉 connention 行的注释，并根据需要修改内网网关以及地址池<br>sudo vim &#x2F;etc&#x2F;ppp&#x2F;chap-secrets</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client server secret IPaddresses ---标题</span><br><span class="line">name pptpd password *</span><br><span class="line">用户名 连接方式 密码 指定IP(*即无指定)</span><br></pre></td></tr></table></figure><p><strong>设置 DNS 解析</strong><br>sudo vim &#x2F;etc&#x2F;ppp&#x2F;pptpd-options<br>取消掉 ms-dns 行的注释，dns 修改成 8.8.8.8 8.8.4.4<br><strong>开启转发功能（必须，否则无法连接外网）</strong><br>sudo vim &#x2F;etc&#x2F;sysctl.conf————取消掉【net.ipv4.ip_forward&#x3D;1】的注释<br><strong>更新配置</strong><br>sudo sysctl -p<br><strong>开启 gre 协议并打开服务器 47,1723 号端口</strong><br>sudo iptables -A INPUT -p gre -j ACCEPT<br>sudo iptables -A INPUT -p tcp –dport 1723 -j ACCEPT<br>sudo iptables -A INPUT -p tcp –dport 47 -j ACCEPT<br><strong>开启 NAT 转发</strong><br>sudo iptables -t nat -A POSTROUTING -s 192.168.88.1&#x2F;24 -o eno1 -j MASQUERADE<br>iptables 永久生效<br>sudo iptables-save<br><strong>重启服务生效</strong><br>service pptpd restart</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;安装 PPTP&lt;/strong&gt;&lt;br&gt;sudo apt-get update&lt;br&gt;sudo apt-get install pptpd&lt;br&gt;&lt;strong&gt;配置 PPTP&lt;/strong&gt;&lt;br&gt;sudo vim &amp;#x2F;etc&amp;#x2F;pptp
      
    
    </summary>
    
    
      <category term="服务" scheme="http://liaozonglong.github.io/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="计算机" scheme="http://liaozonglong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Pptpd" scheme="http://liaozonglong.github.io/tags/Pptpd/"/>
    
  </entry>
  
  <entry>
    <title>Python目录结构</title>
    <link href="http://liaozonglong.github.io/wiki/Python%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://liaozonglong.github.io/wiki/Python目录结构/</id>
    <published>2022-01-25T07:20:41.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<p>&#x2F;<br><strong>–docs————说明文档</strong><br><strong>–db————数据库相关</strong><br><strong>–projectname————源代码</strong><br>—-<strong>pycache</strong>————标注该目录为模块<br>–tests————测试文件目录<br>–main.py————主程序入口<br>–README.md————项目版本说明文件<br>–readme.txt————项目说明文件<br>–requirements.txt——依赖包记录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt   <span class="comment">#生成requirements.txt文件</span></span><br></pre></td></tr></table></figure><p>–setup——脚本安装<br>–test_main.py——测试程序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;#x2F;&lt;br&gt;&lt;strong&gt;–docs————说明文档&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;–db————数据库相关&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;–projectname————源代码&lt;/strong&gt;&lt;br&gt;—-&lt;strong&gt;pycache&lt;/s
      
    
    </summary>
    
    
      <category term="计算机" scheme="http://liaozonglong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="计算机语言" scheme="http://liaozonglong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python目录结构" scheme="http://liaozonglong.github.io/tags/Python%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    
      <category term="Python" scheme="http://liaozonglong.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>控制面板</title>
    <link href="http://liaozonglong.github.io/wiki/%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/"/>
    <id>http://liaozonglong.github.io/wiki/控制面板/</id>
    <published>2022-01-21T02:45:34.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作网络-家庭网络-公共网络"><a href="#工作网络-家庭网络-公共网络" class="headerlink" title="工作网络 家庭网络 公共网络"></a>工作网络 家庭网络 公共网络</h2><ol><li>家庭网络：充分信任的网络——“网络发现”开启、相互”权限”较高</li><li>工作网络：”网络发现”开启、允许共享文件与打印机等</li><li>公共网络：不信任网络——大部分设置都将关闭</li></ol><h2 id="国内时间服务器"><a href="#国内时间服务器" class="headerlink" title="国内时间服务器"></a>国内时间服务器</h2><p>ntp1.aliyun.com<br>ntp2.aliyun.com<br>ntp3.aliyun.com<br>ntp4.aliyun.com<br>ntp5.aliyun.com<br>ntp6.aliyun.com<br>ntp7.aliyun.com</p><ol><li>1</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工作网络-家庭网络-公共网络&quot;&gt;&lt;a href=&quot;#工作网络-家庭网络-公共网络&quot; class=&quot;headerlink&quot; title=&quot;工作网络 家庭网络 公共网络&quot;&gt;&lt;/a&gt;工作网络 家庭网络 公共网络&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;家庭网络：充分信任的网络——“网
      
    
    </summary>
    
    
      <category term="计算机" scheme="http://liaozonglong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="系统" scheme="http://liaozonglong.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Windows" scheme="http://liaozonglong.github.io/tags/Windows/"/>
    
      <category term="系统设置" scheme="http://liaozonglong.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Virtualbox虚拟机里运行Tails Linux</title>
    <link href="http://liaozonglong.github.io/wiki/Virtualbox%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%87%8C%E8%BF%90%E8%A1%8CTails%20Linux/"/>
    <id>http://liaozonglong.github.io/wiki/Virtualbox虚拟机里运行Tails Linux/</id>
    <published>2022-01-12T01:41:25.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<ol><li>下载虚拟机版本，否则 img 镜像无法使用</li><li>选择虚拟机为 Linux，版本选择 32 位 Linux，因为 64 位的 Tails 不能使用 virtualbox 的增强功能。</li></ol><p>​</p><ol start="3"><li>不添加硬盘，因为 tails 不需要</li><li>1</li><li>​</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;下载虚拟机版本，否则 img 镜像无法使用&lt;/li&gt;
&lt;li&gt;选择虚拟机为 Linux，版本选择 32 位 Linux，因为 64 位的 Tails 不能使用 virtualbox 的增强功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;ol start=&quot;3&quot;
      
    
    </summary>
    
    
      <category term="虚拟机" scheme="http://liaozonglong.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>行_如何阅读一本书</title>
    <link href="http://liaozonglong.github.io/wiki/%E8%A1%8C_%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    <id>http://liaozonglong.github.io/wiki/行_如何阅读一本书/</id>
    <published>2022-01-10T04:00:00.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<ol><li>基础阅读<ol><li>阅读一些简单的读物</li><li>快速建立字汇的能力——通过上下文等线索</li><li>精进前面的能力</li></ol></li><li>检视阅读<ol><li>有系统的略读或粗读<ol><li>看书名</li><li>看目录页</li><li>看书中索引</li><li>看书衣</li><li>依据前面建立的对书的认识，寻找看起来与主题相关的阅读</li><li>随机翻阅，一两段\几页(不要多)——寻找主要论点——不要忽略最后两三页</li></ol></li><li>粗浅的阅读<ol><li>1</li><li>阅读的速度</li></ol></li></ol></li></ol><p>用手作为指针，一行行移动下去。然后不断加速</p><ol start="3"><li>检视阅读笔记（结构笔记）<ol><li>这是什么样的一本书？</li><li>整本书在谈的是什么？</li><li>作者是借着怎样的整体架构，来发展他的观点或陈述他对这个主题的理解？</li></ol></li><li>分析阅读<ol><li>分析阅读的第一阶段：找出一本书在谈些什么的规则<ol><li>依照书的种类与主题来分类。</li><li>使用最简短的文字说明整本书在谈些什么。</li><li>将主要部分按顺序与关联性列举出来。将全书的大纲列举出来，并将各个部分的大纲也列出来。<ol><li>一套公式<ol><li>作者将全书分成五个部分<ol><li>第一部分谈什么</li><li>第二部分谈的是别的事</li><li>第三部分谈的是什么</li><li>第四部分则是另外的观点</li><li>第五部分又是另一些事</li></ol></li><li>第一个主要部分又分成三个段落<ol><li>第一段落为 X</li><li>第二段落为 Y</li><li>第三段落为 Z</li></ol></li><li>在第一部分的第一阶段，作者有四个重点<ol><li>第一个重点是 A</li><li>第二个重点是 B</li><li>第三个重点是 C</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><p>……</p><pre><code>  4. 确定作者想要解决的问题。     1. 理论问题     1. 实用问题</code></pre><ol start="2"><li><p>诠释一本书的内容的规则</p><ol><li>诠释作者的关键字，与他达成共识。</li><li>由最重要的句子中，抓住作者的重要主旨。</li><li>知道作者的论述是什么，从内容中找出相关的句子，再重新架构出来。</li><li>确定作者已经解决了哪些问题，还有哪些是没解决的。再判断哪些是作者知道他没解决的问题。</li></ol></li><li><p>像是沟通知识一样地评论一本书的规则</p><ol><li>智慧礼节的一般规则</li><li>除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。（在你说出：“我读懂了!”之前，不要说你同意、不同意或暂缓评论。）</li><li>不要争强好胜，非辩到底不可。</li><li>在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。</li></ol></li><li><p>批评观点的特别标准</p><ol><li>证明作者的知识不足。</li><li>证明作者的知识错误。</li><li>证明作者不合逻辑。</li><li>证明作者的分析与理由是不完整的。</li><li>注意：关于最后这四点，前三点是表示不同意见的准则，如果你无法提出相关的佐证，就必须同意作者的说法，或至少一部分说法。你只能因为最后一点理由，对这本书暂缓评论。</li></ol></li><li><p>主题阅读</p><ol><li>第一阶段：收集书籍<ol><li>观察研究范围：主题阅读的准备阶段</li><li>针对你要研究的主题，设计一份实验性的书目</li><li>浏览你这份书目上的所有书，确定哪些与你的主题相关，并就你的主题建立起清晰的概念</li></ol></li><li>第二阶段：阅读所有第一阶段收集的书籍<ol><li>浏览在第一阶段被认定与你主题相关的书，找出最相关的章节</li><li>根据主题创造出一套中立的词汇，带引作者达成共识</li><li>建立一个中立的主旨，列出一连串的问题</li><li>界定主要及次要的议题</li><li>分析这些讨论</li></ol></li></ol></li><li><p>自我要求</p><ol><li><strong>书的金字塔</strong></li></ol><ul><li>第一类型：百分之九十九得书籍都对你得阅读技巧毫无帮助</li><li>第二类型：可以让你学习得书。当你获取主要概念了，你就不再需要再读一遍了，但你可能要常常翻阅，找出一些特定得重点</li></ul><p>你怎么知道不用再读某一本书了呢？当你的心智反应已经与书中得经验合而为一</p><ul><li>第三类型：无论你如何读，也不可能尽其究竟。</li></ul><p>如何分辨？当你把书放回书架上时，你心中会有点疑惑，好像有什么还没弄清楚得事<br>伟大的书可以适应不同层次得需求。</p></li><li><p>辅助阅读</p><ol><li>相关经验</li><li>其他的书</li><li>导论与摘要</li><li>工具书</li><li>外在阅读的规则：除非你看完了一本书，否则不要看某个人的导读</li></ol></li></ol><hr><p>如何阅读实用书<br>任何书里包含了规则——原理、准则或任何一种一般的指导——你都要认定是一本实用性的书。但是一本实用性的书所包含的不只是规则而已。它可能会说明规则底下的原理，使之浅显易懂。</p><ul><li>两种实用书<ul><li>谈论关于某件事如何行动的书</li><li>主要谈的是规则背后的原理，主要解决的问题终究是实用的问题——行动的问题</li></ul></li><li>主要获取对象：共识、主旨、论述</li></ul><p>​</p><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;基础阅读&lt;ol&gt;
&lt;li&gt;阅读一些简单的读物&lt;/li&gt;
&lt;li&gt;快速建立字汇的能力——通过上下文等线索&lt;/li&gt;
&lt;li&gt;精进前面的能力&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;检视阅读&lt;ol&gt;
&lt;li&gt;有系统的略读或粗读&lt;ol&gt;
&lt;li&gt;看书名&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="如何阅读一本书" scheme="http://liaozonglong.github.io/tags/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    
      <category term="方法论" scheme="http://liaozonglong.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读一本书</title>
    <link href="http://liaozonglong.github.io/wiki/%E7%9F%A5_%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    <id>http://liaozonglong.github.io/wiki/知_如何阅读一本书/</id>
    <published>2022-01-10T04:00:00.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<ol><li>序言<ol><li>说明社会对于阅读书籍的状态。</li><li>介绍阅读的四种层次：<ol><li>基础阅读、分析阅读、主题阅读</li></ol></li></ol></li></ol><hr><h2 id="第一篇：阅读的层次"><a href="#第一篇：阅读的层次" class="headerlink" title="第一篇：阅读的层次"></a>第一篇：阅读的层次</h2><p>test</p><h3 id="第一章-阅读的活力与艺术"><a href="#第一章-阅读的活力与艺术" class="headerlink" title="第一章 阅读的活力与艺术"></a>第一章 阅读的活力与艺术</h3><p>此书的主要目的是为了将读书当作是增加理解能力的人而写。<br>知识是理解力的前提但不等于理解力。太多的资讯就如同太少的资讯一样，都是一种对理解力的阻碍。<br>long：其实也跟利弗莫尔的开头一样。核心就是为愿意努力的人而写</p><ol><li>主动的阅读</li></ol><p>以下阅读技巧适用于所有读物上</p><ol><li>第一提醒</li></ol><p>阅读可以是一件多少主动的事</p><ol start="2"><li>第二指出</li></ol><p>阅读越主动，效果越好<br>听众或读者的“ 接收”，应该像是棒球赛中的捕手才对。</p><hr><ol start="2"><li>阅读的目标<ol><li>你对一本书的内容的了解程度<ol><li>你很明白一本书</li></ol></li></ol></li></ol><p>这本书中的讯息只是将你还没读这本书之前，你们便共同了解的东西传达出来而已</p><pre><code>  2. 你并不完全了解这本书。     1. 你对这本书的了解程度，刚好让你明白其实你并不了解这本书</code></pre><p>long：这个本身就要具备一定的能力，才能认识到自己的局限</p><pre><code>        1. 以下条件不是真正地在阅读           1. 把书给别人，让他解释           1. 决定不在为这本书伤脑筋，认为理解的已经够多了        2. 只有一种真正的阅读</code></pre><p>不借助外力，凭内心的力量，玩味眼前的字句，从模糊到清晰<br>作者：这个过程就是由许多不同活动所组成的阅读的艺术<br>long：这一段跟作者第一个问题有关，也是联系后面的主要提要</p><pre><code>     2. 阅读的两种意义        1. 阅读报纸、杂志等一下子便能融会贯通的东西。</code></pre><p>这样的读物能增加我们的咨询、不能增加我们的理解</p><pre><code>        2. 试着读一种他并不怎么了解的东西           1. 这个东西的水平要比阅读的人高一截</code></pre><p>这种“学习”是指理解更多的事情，而不是知道更多信息</p><pre><code>           2. 从阅读信息中出发，但寻找其中的更加关键的信息。</code></pre><p>这种阅读咨询的阅读，也事进行第二种增加理解理解力的阅读。<br>作者：主要就是，从读物中超越原先的理解<br>事实上，任何一本书能增进理解或增加资讯时，也就同时有了消遣的效果。就像一本能够增进我们理解力的书，也可以纯粹只读其中所包含的资讯一样。(这个情况并不是倒过来也成立：并不是每一种拿来消遣的书，都能当作增进我们的理解力来读。) 我们也绝不是在鼓励你绝不要阅读任何消遣的书。重点在于，如果你想要读一本有助于增进理解力的好书，那我们是可以帮得上忙的。因此，如果增进理解力是你的目标，<strong>我们的主题就是阅读好书的艺术</strong>。<br>long：其实作者是做了一个关于好书的前提定义的，也就是说，这些阅读技巧虽然哪里都能用，但最好只用在好书上</p><hr><ol start="3"><li>阅读就是学习</li></ol><p>如果你运用的只是你的记忆力，其实你除了那些讯息之外一无所获。你并没有被启发。要能被启发，除了知道作者所说的话之外,还要明白他的意思，懂得他为什么会这么说。</p><ol><li>指导型学习</li></ol><p>而被引导的学习就是要旁人的帮助。我们可以称指导 型的学习是辅助型的自我发现学习</p><ol start="2"><li>自我发现型学习</li></ol><p>自我发现的学习方式就是没有老师指导的方式<br>思考只是主动阅读的一部分。一个人还必须运用他的感觉与想象力</p><ol start="3"><li>两者差异</li></ol><p>不论是哪一种方式，只有真正学习到的人才是主动的学习者。因此，如果说自我发现的学习是主动的，指导性的学习是被动的，很可能会造成谬误。其实，任何学习都不该没有活力，就像任何阅都不应该死气沉沉<br>相对于主动的阅读——追求理解力的阅读——来说，一个人在被指导阅读或阅读资讯或消遣时，确实可能思考得较少 一些。<br>出席的老师与缺席的老师。问一本书问题，你能做的只有自己找出答案。对于问题的回答，要懂得如何让自己变成出席的老师，让自己教导我们。除非我们能理解，否则我们什么都不会</p><ol start="4"><li>阅读的艺术</li></ol><p>阅读的艺术包括了所有非辅助型自我发现学习的技巧:敏锐的观察,灵敏可靠的记忆,想象的空间,再者当然就是训练有素的分析、和省思能力</p><hr><p>作者的问题：</p><ol><li>主动的阅读包括哪些条件？<ol><li>思考只是主动阅读的一部分。一个人还必须运用他的感觉与想象力。一个人必须观察，记忆，在看不到的地方运用想象力。<ol><li>思考</li><li>感觉</li><li>想象力</li></ol></li></ol></li></ol><hr><p>作者的定义:</p><ol><li>阅读的艺术：<ol><li>这样我们就可以粗略地为所谓的阅读艺术下个定义:这是一个凭借着头脑运作，除了玩味读物中的些字句之外,不假任何外助，以一己之力来提升自我的过程。你的头脑会从粗浅的了解推进到深入的理解。</li><li>简单地说，阅读的艺术包括了所有非辅助型自我发现学习的技巧：敏锐的观察、灵敏可靠的记忆、想象的空间，再者当然就是训练有素的分析、省思能力</li></ol></li></ol><hr><p>总结：<br>​</p><p>​</p><hr><h3 id="第二章-阅读的层次"><a href="#第二章-阅读的层次" class="headerlink" title="第二章 阅读的层次"></a>第二章 阅读的层次</h3><p>一般来说，阅读的规则是：努力越多，效果越好<br>阅读，就像是非辅助性的自我发现学习，是跟着一位缺席的老师在学习。只有当我们知道如何去读时，我们才可能真正读懂</p><ol><li>四种层次</li></ol><p>一共有四种层次的阅读。且高层次也包含低层次</p><ol><li>第一层：基础阅读</li></ol><p>在这个层次的阅读中，要问读者的问题是:“这个句子在说什么？——即认字识字</p><ol start="2"><li>第二层：检视阅读：<ol><li>特点</li></ol></li></ol><p>强调时间——在一定时间之内，抓出一本书的重点</p><pre><code>  2. 你要回答的问题</code></pre><p>这是哪一类书——小说、历史还是科学论文？</p><ol start="3"><li>第三层：分析阅读：</li></ol><p>全盘的阅读、完整的阅读。如果说检视阅读是在有限的时间内，最好也最完整的阅读，那么分析阅读就是在无限的时间里，最好也最完整的阅读。<br>在这个层次的阅读中，读者会抓住一本书，一直要读到这本书成为他自己为止<br>分析阅读就是要咀嚼与消化一本书</p><ol start="4"><li>第四层：主题阅读</li></ol><p>主题阅读时，阅读则会读很多书，而不是一本书，并列举这些书之间相关支出，提出一个所有的书都谈到的主题<br>主题阅读可能是所有阅读活动中最有收获的</p><hr><h3 id="第三章-阅读的第一个层次：基础阅读"><a href="#第三章-阅读的第一个层次：基础阅读" class="headerlink" title="第三章 阅读的第一个层次：基础阅读"></a>第三章 阅读的第一个层次：基础阅读</h3><ol><li>三个历史趋势<ol><li>全民教育</li><li>阅读教育本身<ol><li>ABC 教学法</li><li>发音发——认字不是由字母来认，而是由发音来辨识</li><li>视觉发——先看整个句子的含义，才学习单字</li></ol></li><li>对教育系统的批评</li></ol></li></ol><hr><ol start="2"><li>学习阅读的四个阶段<ol><li>第一阶段：阅读准备阶段——从出生，直到六七岁为止。即生理方面的准备</li><li>第二阶段：阅读一些简单的读物</li><li>第三阶段：快速建立字汇的能力——通过上下文的线索，“揭发”不熟悉的字眼</li><li>第四阶段：精炼与增进前面所学的技巧——最重要的，一个人开始消化他的阅读经验——从一本书所提出的观点转变成另一个观点，对不同作者的观点进行比较</li></ol></li><li>更高层次的阅读与高等教育</li></ol><p>个人文素养优良的高中,就算什么也没做，也该培养出能达到分析阅读的读者。个优秀的大学，就算什么也没贡献，也该培育出能进行题阅读的读者。大学的文凭应该代表着一般大学毕业生的阅读水平，不但能够阅读任何一种普通的资料，还能针对任何一种主题做个人的研究（这就是在所有阅读中，主题阅读能让你做到的事）。然而，通常大学生要在毕业以后，再读三四年的时间才能达到这样的程度，并且还不见得一定达到。</p><hr><p>作者的定义：</p><ol><li>矫正阅读：矫正阅读的指导并不算指导。他做的只是把学生带到一个他在小学毕业就该具备的阅读能力程度——例如：有效阅读法、竞读之类的课程</li></ol><hr><p>作者的理念：</p><ol><li>阅读与民主教育的理念：</li></ol><p>我们应该警觉,当务之急是必须从最低层次的、最小公倍数的阅读教起<br>甚至，此刻我们也不想提是否需要另一种教育方式了。我们的历史一直强调，无限制的受教育机会是一个社会能提供给人民最有价值的服务或说得正确一点，只有当一个人的自我期许，能力与需要受限制时，教育机会才会受到限制。我们还没有办法提供这种机会之前，不表示我们就有理由要放弃尝试。<br>但是我们包括学生、老师与门外汉等也要明白：就算我们完成了眼前的任务，仍然还没有完成整个工作。我们一定要比一个人人识字的国家更进一步。我们的国人应该变成一个个真正“有能力”的阅读者，能够真正认知“有能力”这个字眼中的涵义。达不到这样的境界，我们就无法应付未来世界的需求。</p><hr><h3 id="第四章-阅读的第二个层次：检视阅读"><a href="#第四章-阅读的第二个层次：检视阅读" class="headerlink" title="第四章 阅读的第二个层次：检视阅读"></a>第四章 阅读的第二个层次：检视阅读</h3><p>检视阅读，才算真正进入阅读的层次<br>首先要理解的是，检视阅读一共有两种。本来这是一体两面的事，但是对一个刚起步的阅读者来说，最好是将两者区别为不同的步骤与活动。</p><hr><ol><li>检视阅读一：有系统的略读或粗读<ol><li>目标：你的目标是要发现这本书值不值得多花时间仔细阅读。</li><li>方法<ol><li>先看书名页，然后如果有序就先看序。要很快地看过去。特别注意副标题，或其他相关说明或宗旨，或作者写这本书的特殊角度。到此为止，如果你愿意，你可以将这本书归为某个特定的类型。而在那个类型中，已经包含了哪些书</li><li>研究目录页，对这本书的基本架构做概括性的理解</li><li>如果书中附有索引，也要检阅一下。快速评估这本书涵盖哪些议题的范围。如果你发现列举出哪一条词汇很重要，至少要看一下引用这个词目的某几页内文</li><li>如果那是本包着书衣的新书，不妨读一下出版者的介绍</li><li>你从对一本书的目录很概略，甚至还有点模糊的印象中，挑几个看来跟主题息息相关的文章来看</li><li>最后一步，随机翻阅这本书，一两段，有时连续几页，但不要多。全书过一遍，随时寻早主要论点的信号。最重要的是，不要忽略最后的两三页，就算是后记。</li></ol></li></ol></li><li>检视阅读二粗浅的阅读</li></ol><p>只要找对的方向，不论多难读的书，只要原来就是想写给大众读者看的，那就不该有望之却步的理由<br>我们大多数人所受的教育，都说是要去注意那些我们不懂的地方。我们被教导说，碰到生字，就去查字典。我们被教导说，读到一些不明白的隐喻或论说，就去查百科全书或其他相关资料。我们被教导说，要去查注脚、学者的注释或其他的二手资料以获得帮助。但是如果时候不到就做这些事，却只会妨碍我们的阅读，而非帮助。</p><ol><li>阅读的速度</li></ol><p>我们大多数人应该有能力比他们现在读的速度还更快一点</p><pre><code>  1. 逗留与倒退</code></pre><p>我们的视线会不自觉地逗留。</p><pre><code>     1. 矫正</code></pre><p>用手作为指针，一行行移动下去。然后不断加速</p><pre><code>  2. 理解问题</code></pre><p>用手作为指针也会加强你的注意力<br>但加强注意力不等于理解——没有经过分析阅读，你就无法理解一本书</p><hr><p>作者的问题：</p><ol><li>检视阅读中究竟包含了些什么？你要怎样才能培养检视阅读的能力呢？</li><li>什么是对的方向</li></ol><p>头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不要停下来查询或思索</p><h3 id="第五章-如何做一个自我要求的读者"><a href="#第五章-如何做一个自我要求的读者" class="headerlink" title="第五章 如何做一个自我要求的读者"></a>第五章 如何做一个自我要求的读者</h3><p>在阅读的时候想要保持清醒，或昏昏入睡，主要看你的阅读目标是什么。如果你的阅读目标是获得利益不论是心灵或精神上的成长你就得保持清醒。这也意味着在阅读时要尽可能</p><ol><li>主动的阅读基础：一个阅读者要提出的四个基本问题</li></ol><p>任何一种超越基础阅读的阅读层次，核心就在于你要努力提出问题（然后尽你可能地找出答案）</p><ol><li>整体来说，这本书到底在谈什么？</li><li>作者细部说了什么，怎么说的</li><li>这本书说的有道理吗？</li><li>这本书跟你什么关系？</li><li>如何让一本书真正属于你自己<ol><li>笔记</li></ol></li></ol><p>俗话说：“你必须读出言外之意，才会有更大的收获”。我们也鼓励你“写出言外之意”</p><pre><code>  1. 关于用笔的好处     1. 第一：这会让你保持非常清醒     1. 第二：主动的阅读就是一种思考，而思考倾向于用语言表达出来     1. 第三：将你的感想写下来，能帮助你记住作者的思想  2. 用笔的方法     1. 画底线     1. 底下下再加一道线——二次强调     1. 用其他特殊符号标记——特别强调——慎用，只用来强调书中十来个最重要的声明或段落即可     1. 在空白处编号——作者的论点发展     1. 空白处记下其他页码——说明作者在别处有同样的论点——集中思想     1. 圈字——类似画底线     1. 书页空白处笔记——主要论点发展顺序。书中最后一页可以用来作为个人的索引页，将作者的主要观点依序记下来  3. 三种做笔记的方法     1. 结构笔记        1. 第一：这是一本什么样的书？        1. 第二：整本书在谈的是什么？        1. 第三：作者是借着怎样的架构，来发展或陈述他对这个主题的理解？     2. 概念笔记</code></pre><p>这些概念是作者的观点，而当你读得越深越广时，便也会出现你自己的观点了</p><pre><code>     3. 辩证笔记</code></pre><ol start="3"><li>培养阅读的习惯</li></ol><p>除了不断练习，别无他法<br>我们谈到一个有技术的人时，并不是在说他指导该如何去做那件事，而是他已经养成去做那件事的习惯了</p><ol start="4"><li>由许多规则中养成一个习惯</li></ol><p>应当做的不是将所有动作分开来想，而是连贯在一起。但是为了忘掉这些单一的动作，一开始你必须先分别学会每一个单一的动作<br>等所有的动作不再分离，渐渐融为一体，学习者便能将注意力转移到目标上了，而他也具备了要达成目标的能力了</p><h2 id="第二篇：阅读的第三个层次：分析阅读"><a href="#第二篇：阅读的第三个层次：分析阅读" class="headerlink" title="第二篇：阅读的第三个层次：分析阅读"></a>第二篇：阅读的第三个层次：分析阅读</h2><h3 id="第六章-一本书的分类"><a href="#第六章-一本书的分类" class="headerlink" title="第六章 一本书的分类"></a>第六章 一本书的分类</h3><ol><li>书籍分类的重要性</li></ol><p>分析阅读的第一个规则可以这么说：规则你一定要知道自己在读的是哪一类书，而且要越早知道越好。最好早在你开始阅读之前就先知道。<br>我们要知道的不只是哪一类的书带给我们指导，还要知道是用什么方法指导。历史类的书与哲学类的书，所提供的知识与启发方式就截然不同。在物理学或伦理学上，处理同一个问题的方法可能也不尽相同。更别提各个不同作者在处理这么多不同问题时所应用的各种不同方法了。</p><ol start="2"><li>从一本书的书名中你能学到什么</li></ol><p>作者不怕麻烦再前言中做说明。通常也试着想让他的书名——至少副标题——是让人能理解的<br>要跟随第一个阅读步骤，你一定要知道这个种类的书到底是在谈些什么？书名不会告诉你，前言等等也不会说明，有时甚至整本书都说不清楚，只有当你自己心中有一个分类的标准，你才能做明智的判断。</p><ol start="3"><li>实用性 vs 理论性作品<ol><li>实用性的书</li></ol></li></ol><p>任何一本指南类的书都是实用的。任何一本书告诉你要该做什么，或如何去做，都是实用的书。<br>严格来说，任何一本教我们如何生活，该做什么，不该做什么，同时说明做了会有什么奖赏，不做会有什么惩罚的伦理的书，不论我们是否同意他的结论，都得认定这是一本实用的书。</p><hr><ol start="2"><li>理论性性的书</li></ol><p>有些现代的社会学研究只提供人类的行为观察，而不加以批判，既非伦理也无关实用，那就是理论型的书</p><pre><code>  1. 理论性作品的分类     1. 历史就是纪事——即发生在一段特定时间的真实事情     1. 科学不会太在意过去——面对的是任何时间、地点都会发生的事情——定律或通则</code></pre><p>哲学比较像科学，不像历史，追求的是一般真理，而非发生在过去的特定事件</p><pre><code>        1. 如何判断哲学与科学的书</code></pre><p>有一个判断依据我觉得永远有效，不过你可能要把一本书的内容读了相当多之后才能应用。——如果一本理论的书所强调的内容，超乎你日常、例行、正常的生活的经验，那就是科学的书。否则就是一本哲学的书</p><hr><ol start="3"><li>区别</li></ol><p>质疑某件事的有效性是理论，而质疑任何事的目的，却是实用。<br>Jack 注解：<br>质疑某件事，之所以是理论，即对事物的原理进行质疑，论述。；质疑所有事，之所以是实用，即对事物的原理，以及行为的有效性质疑。</p><ol start="4"><li>作者追加说明</li></ol><p>你会发现有很多读者分不清理论与实用的区别，就像一个小说家搞不清楚什么是虚构故事，什么是社会学。你也会发现有些书，一部分是这类，另一部分是另一类。但是，作为一个读者，具有辨识的优势，通过这个优势，你会更好的处理这个作品</p><hr><p>作者的问题：</p><ol><li>你可能会问，我们在看论说性的作品时，不就是在接受知识的传递吗？这样怎么会有行动可言？</li></ol><p>答案是，当然有，明智的行动就是来自知识。知识可以用在许多方面，不只是控制自然，发明工具，还可以指导人类的行为等等<br>要让知识变成实用，就要有操作的规则。我们一定要超越“知道这是怎么回事”,进而明白“如果我们想做些什么，应该怎么利用它”</p><hr><h3 id="第七章-透视一本书"><a href="#第七章-透视一本书" class="headerlink" title="第七章 透视一本书"></a>第七章 透视一本书</h3><blockquote><p>分析阅读的第一个规则可以这么说：规则你一定要知道自己在读的是哪一类书，而且要越早知道越好。最好早在你开始阅读之前就先知道。<br>分析阅读的第二个规则是：使用一个单一的句子，或最多几句话来叙述整本书的内容<br>第三个规则是：将书中重要的篇章列举出来，说明他们如何按照顺序组成一个整体的架构<br>第四个规则是：找出作者要问的问题。一本书作者在开始写作时，都是有一个或一连串的问题，而这本书的内容就是一个答案，或许多答案</p></blockquote><p>一本好书，就像一栋好房子，每个部分都要很有秩序地排列起来。每个重要部分都要有一定独立性。装饰、架构可能跟其他部分不同。但是却一定要跟其他部分连接起来——这是与功能相关——否则这个部分便无法对整体的智能架构做出任何贡献了。<br>一本好书的架构通常比差一些的书要复杂，但是复杂也事一种单纯，因为他们的各个部分都组织得更完善，也更统一<br>只要大致还可以，只要内容不仅是集合体，还够得上是某种程度的整体组合，那其中就必然有一个架构规划，而你一定要找出来才行</p><ol><li>四个规则之后三个：<ol><li>结构与规划：叙述整本书的大意</li></ol></li></ol><p>通过了解一个故事的大意后，透过整体调性统一的叙述，你就能将不同情节部分放入正确的位置了<br>同样的基本情节，一位作者写出来的是好故事或怀故事，端看他如何装点这幅骨架<br>如果作者提供帮助，不要因为太骄傲而拒绝。但是，也不要完全依赖他在前言中所说的话。你可以借着指引来读，但是永远要记住，最后找出一个架构是读者的责任，就跟当初作者有责任自己设定一个架构一样。只有当你读完整本书时，才能诚实地放下这个责任</p><ol start="2"><li>驾驭复杂的内容：为一本书拟大纲的技巧</li></ol><p>这个规则要求我们将一本书最重要的部分按照秩序与关系，列举出来。<br>与第二个规则的联系是，你不清楚构成部分，就没法理解全书。</p><pre><code>  1. 一套公式     1. 作者将全书分成五个部分        1. 第一部分谈什么        1. 第二部分谈的是别的事        1. 第三部分谈的是什么        1. 第四部分则是另外的观点        1. 第五部分又是另一些事     2. 第一个主要部分又分成三个段落        1. 第一段落为X        1. 第二段落为Y        1. 第三段落为Z     3. 在第一部分的第一阶段，作者有四个重点        1. 第一个重点是A        1. 第二个重点是B        1. 第三个重点是C</code></pre><p>……<br>这个规则并不是要完全写出来，但是需要习惯性的这么做——也就是做到“大概”<br>并且这个规则没有要求你将作者没有放进去的东西加在里面。毕竟一个主题是具有无限延伸的可能的</p><ol start="3"><li>发现作者的意图</li></ol><p>如果你已经在运用规则二与规则三了的话。那么这个规则就不过是换了种说法而已。</p><blockquote><p>第四个规则是：找出作者要问的问题。一本书作者在开始写作时，都是有一个或一连串的问题，而这本书的内容就是一个答案，或许多答案</p></blockquote><pre><code>  1. 典型的理论问题</code></pre><p>某件事存在吗？是什么样的事？发生的原因是什么？或是在什么样的情况下存在？或为什么会有这件事的存在？这件事的目的是什么？造成的影响是什么？特性及特征是什么？与其他类似事件，或不相同事件的关联是什么？这件事是如何进行的？</p><pre><code>  2. 典型的实用问题</code></pre><p>有哪些结果可以选择？应该采取什么样的手段才能获得某种结果？要达到某个目的，应该采取哪些行动？以什么顺序？在这些条件下，什么事是对的，或怎样才会更好，而不是更糟？在什么样的条件下，这样做会比那样做好一些？</p><ol start="2"><li>分析阅读的第一个阶段</li></ol><p>除非你是刚开始练习，否则你不该将“阶段”一词当作一个前后顺序的概念。真正实际的读者应该是一词就完成所有的阶段</p><ol start="2"><li>总结<ol><li>依照书本的种类与主题作分类</li><li>用最简单的句子说出整本书在谈什么</li><li>诏安顺序与关系，列出全书的重要部分。全书的纲要拟出来之后，再将各个部分的纲要也一一列出</li><li>找出作者在问的问题，或作者想要解决的问题</li></ol></li></ol><h3 id="第八章-与作者找出共同的词义"><a href="#第八章-与作者找出共同的词义" class="headerlink" title="第八章 与作者找出共同的词义"></a>第八章 与作者找出共同的词义</h3><p>主旨：</p><ol><li>找出关键字，与作者达成共识</li></ol><hr><p>除非读者与作者能找出共同的词义，否则想要把知识从一方传递到另一方是不可能的事，因为词义是可供沟通的知识的基本要素</p><ol><li>单字 vs 词义</li></ol><p>一个作者用一个单字是这个意义，而读者却读成其他的意义，那么这个单字就在他们之间擦身而过<br>你不能在字典中找到词义，虽然那里有制造词义的原料<br>这个阶段主要是要诠释内容与讯息</p><ol><li>找出关键字</li></ol><p>有一件事你可以确定：并不是作者所使用的每一个字都很重要。更进一步说，作者所使用的字大多数都不重要。只有当他以特殊的方法来运用一些字的时候，那些字对他来说，对身为读者的我们来说，才是重要的。<br>从一个读者的角度来看，最重要的字就是那些让你头疼的字</p><ol start="2"><li>专门用语及特殊字汇</li></ol><p>主要内容——问题 3<br>大多数读者的问题，在于他们根本就不太注意文字，找不出他们的困难点。如果你在读一本有助于增进理解力的书，那你可能无法了解这本书里的每一个字，是很合理的。如果你不进一步试着了解这些字、了解一本书，这本书对你就一点启发也没有了</p><ol start="3"><li>找出字义</li></ol><p>假设你已经找出你需要努力的地方——不认识的字汇。那么还存在两个可能</p><pre><code>  1. 作者在全书每个地方用这个字眼都只有单一的意义  1. 作者同一个字他会使用两三种意义</code></pre><p>主要内容——问题 4-5<br>如果存在多重意义，要看这些意义之间的关系如何</p><pre><code>  3. 作者几个字可能只有一个意义</code></pre><p>一个词义可能与好几个字有关</p><pre><code>  4. 片语</code></pre><p>一个片语，可以像单字一样，形容某件事。也就是——可以代替字义。<br>相较于单字，片语更加清晰，上下文都有关联。能充分表达作者的意思。</p><hr><p>问题：</p><ol><li>如果我跟作者没达成共同的词义，那么我怎么列的大纲？</li></ol><p>等到自己完全理解作者的意思再列大纲</p><ol start="2"><li>可供沟通的知识的基本要素有哪些</li><li>是否有其他方法，找出更重要的字眼？是否有更积极的方法找出这个关键字？</li></ol><p>第一个：作者开诚布公地强调某些字，而不是其他的字。比如区分字体，加特殊符号<br>第二个：某些主题有一套完整的专门用语，在一本这种主题的书中找出重要的单字，相形之下就很容易了<br>第三个：作者与其他作者争执的某个用语就是重要的字</p><ol start="4"><li>你到底要怎么样才能掌握这许多不同——字汇——的意思呢？</li></ol><p>你一定要利用上下文自己已经了解的所有字句，来推敲你所不了解的那个字的意义。不论这个方法如何，但却是唯一方法<br>这个过程就像拼图游戏，拼起来的越多，剩下的部分就越少</p><ol start="5"><li>一个作者使用一个字的多重意义，难道就不是用字用得模糊不清吗？作者使用一个字，特别是非常重要得字时，包含多重意义不是很平常得事吗？</li></ol><p>第一个回答：不是<br>第二个回答：没错，所谓模糊不清，是使用这个字的多重含义时，没有区别或之处其中相关的意义</p><hr><h3 id="第九章-判断作者的主旨"><a href="#第九章-判断作者的主旨" class="headerlink" title="第九章 判断作者的主旨"></a>第九章 判断作者的主旨</h3><p>定义：</p><ol><li>提案：一个人提案，就是声明他准备依照某种模式来做事的意图</li><li>口语主义：可以说是一种使用文字，没有体会其中的思想传达，或没有注意到其中指的经验的坏习惯</li><li>论述：一系列先后有序，其中某些还带有提出例证与理由作用的主旨</li></ol><hr><p>主旨：</p><ol><li>第六个规则：将一本书中最重要的句子圈出来，找出其中的主旨</li><li>第七个规则：从相关文句的关联中，设法架构出一本书的基本论述</li></ol><hr><p>作者的主旨，就是作者在表达他对某件事的判断。他断言某件他认为是真的事。这样的提案，是一种知识的声明，而不是意图的声明。作者的意图可能在前言的一开头就告诉我们了。<br>为了判断作者有无遵守意图，我们就一定要找出他的主旨才行</p><ol><li>句子与主旨</li></ol><p>并不是每个句子都是谈论主旨。有时候，一些句子在表达的是疑问，提出的是问题。主旨则是问题的回答<br>只要文字、句子与段落是不透明的、未解析的，他们就是沟通的障碍，而不是媒介。<br>不同的句子可以表达同一个主旨</p><ol start="2"><li>找出关键句</li></ol><p>相关：问题 1<br>阅读的一部分本质就是被困惑，而且知道自己被困惑。怀疑是智慧的开始，从书本上学习跟从大自然学习是一样的。</p><ol start="3"><li>找出主旨</li></ol><p>复杂的句子通常要说明的不只一个主旨。除非你能分析出所有不同或相关的主旨，否则你还是无法完全诠释一个重要的句子。<br>作者以及不同的作者经常会用不同的字眼诉说同一件事，或是用同样的字眼来说不同的事。一个读者如果不能经由文字语言看出意思与主旨，就永远不能作相关作品的比较</p><ol start="4"><li>找出论述</li></ol><p>作者写作的时候，并没有设定段落的定则可循<br>公式：如果可以，找出书中说明重要论述的段落。</p><pre><code>  1. 某些论述可能是跨章节呈现的  1. 论述的组成有可能出现证据的说明，证据的收集方法。这一类是离题比较远，可以快速阅读的部分  1. 任何一个好的论述都可以作成简要的说明。  1. 论述的开端两种模式     1. 作者与读者都同意的假设     1. 作者与读者都无法否认的自明之理</code></pre><p>要记住，所有的论述都包含了一些声明。其中有些是你为什么接受作者这个论述的理由。如果你先找到结论，就去看看理由是什么。如果你先看到理由，就找找看这些理由带引你到什么样的结论上<br>两种论述的不同之处</p><pre><code>  1. 一种是以一个或多个特殊的事实证明某种共同的概念——归纳法  1. 另一种是以连串的通则来证明更进一步的共通概念——演绎法</code></pre><ol start="5"><li>找出解答</li></ol><p>最后一个步骤：找出作者在书中想要解决的主要问题</p><ol start="6"><li>分析阅读的第二个阶段</li></ol><p>分析阅读的第二个阶段，或找出一本书到底在说什么的规则<br>（诠释一本书的内容）：<br>（5）诠释作者使用的关键字，与作者达成共识。<br>（6）从最重要的句子中抓出作者的重要主旨。<br>（7）找出作者的论述，重新架构这些论述的前因后果，以<br>明白作者的主张。<br>（8）确定作者已经解决了哪些问题，还有哪些是未解决的。<br>在未解决的问题中，确定哪些是作者认为自己无法解决的问题。</p><hr><p>作者的建议：</p><ol><li>用你自己的话将其中的主旨写出来。列出号码，找出其间的相关性</li><li>第七个规则可以有另一个公式：如果可以，找出书中说明重要论述的段落。但是，如果这个论述并没有这样表达出来，你就要去架构出来。你要从这一段或那一段中挑选句子出来，然后整理出前后顺序的主旨，以及其组成的论述</li></ol><hr><p>问题：</p><ol><li>在一本书中，最重要的句子在哪里？要如何诠释这些句子，才能找到其中包含的一个或多个主旨？</li></ol><p>对你重要的句子就是一些需要花一点努力来诠释的句子，因为你第一眼看到这些句子时并不能完全理解。<br>你能不能举出一个自己所经历过的主旨所形容的经验，或与主旨有某种相关的经验？<br>你能不能就作者所阐述的特殊情况，说明其中通用于一般道理？<br>用你自己的话来说——是测试你懂不懂一个句子的主旨的最佳方法</p><hr><h3 id="第十章-公正地评断一本书"><a href="#第十章-公正地评断一本书" class="headerlink" title="第十章 公正地评断一本书"></a>第十章 公正地评断一本书</h3><p>主旨：<br>规则十：当你不同意作者的观点时，要例行地表达自己的意见，不要无理地辩驳或争论<br>规则十一：尊重知识与个人观点的不同，在作任何评断之前，都要找出理论基础</p><hr><p>阅读一本书，是一种对话。读者应当在作者说完后开口。如果你没有，你就是不了解一个读者的义务——也没有掌握住自己的机会。没我自我期许的读者没法达到这个要求，他们不但没心力去理解一本书，甚至根本将书搁在一边，忘个一干二净</p><ol><li>受教是一种美德</li></ol><p>一般人通常认为，水准普通的读者是不够格评论一本好书的。的确，如果一本书会启发读者，就表示作者高于读者，除非读者完全了解这本书，否则是不该批评的。但是等他们能这么做时，表示他们已经自我提升到与作者同样的水平了。这时，如果他们不执行他们的特权，对于作者来说就是不公平的<br>最能学习的读者，也就是最能批评的读者</p><ol start="2"><li>修辞的作用</li></ol><p>修辞就是要知道如何去说服对方。——也就是论述中的逻辑，如何使作品更加明确清晰</p><ol start="3"><li>暂缓评论的重要性</li></ol><p>除非你听清楚了，也确定自己了解了，否则就不要回话<br>如果你不能，或者是不能用自己的话重述作者的观点，就时没了解<br>在读一本好的书时，假设“我不懂”是有好处的。通常这个过程是读者的错</p><ol start="4"><li>避免争强好辩的重要性</li></ol><p>当你不同意作者的观点时，要例行地表达自己的意见，不要无理地辩驳或争论<br>“其实这就是我们的责任。为了追求真理，要毁掉一些<br>我们内心最亲近的事物，尤其像我们这样的哲学家或热爱智<br>慧的人更是如此。因为，纵使双方是挚友，我们对真理的皮<br>诚却是超越友谊的。”<br>谈话不是战争，我们要得到的是真理，而不是胜利</p><ol start="5"><li>化解争议</li></ol><p>在争论中，一个人绝不能忘了这是教导别人，也是自己受教的一个机会<br>争议是可争辩之物。除非双方相信透过相关证据的公开，彼此可以借由理性来达成一种理解，进而理解原始的争议议题，否则争议只是毫无意义的事。<br>当读者发现自己的观点与书中不合时就可以运用这个规则了。</p><h3 id="第十一章-赞同或反对作者"><a href="#第十一章-赞同或反对作者" class="headerlink" title="第十一章 赞同或反对作者"></a>第十一章 赞同或反对作者</h3><p>假设你在读一本好书，也就是说这是一本可以理解的书。再假设最后你终于可以说：“我懂了！”再假设你除了看懂了全书之外，还对作者 的意见完全赞同，这样，阅读的工作才算是完成了。当然，如果你对作者的意见不同或暂缓评论。我们还会有进一步的考量。尤其是不同的情况比较常见<br>只有双方都了解对方所说的话的内容事，关于事实或方向的议题——关于一件事是什么或该如何做的议题——才是真实的。在讨论一件事时，双方都要对文字上的应用没有意见之后，次啊能谈到同意或不同意的观点。</p><hr><h4 id="分析阅读的三阶段"><a href="#分析阅读的三阶段" class="headerlink" title="分析阅读的三阶段"></a>分析阅读的三阶段</h4><p>分析阅读的第一阶段：找出一本书在谈些什么的规则<br>（1）依照书的种类与主题来分类。<br>（2）使用最简短的文字说明整本书在谈些什么。<br>（3）将主要部分按顺序与关联性列举出来。将全书的大纲列举出来，并将各个部分的大纲也列出来。<br>（4）确定作者想要解决的问题。<br>二、分析阅读的第二阶段：诠释一本书的内容规则<br>（5）诠释作者的关键字，与他达成共识。<br>（6）由最重要的句子中，抓住作者的重要主旨。<br>（7）知道作者的论述是什么，从内容中找出相关的句子，再重新架构出来。<br>（8）确定作者已经解决了哪些问题，还有哪些是没解决的。再判断哪些是作者知道他没解决的问题。<br>三、分析阅读的第三阶段：像是沟通知识一样地评论一本书的规则<br>A．智慧礼节的一般规则<br>（9）除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。（在你说出：“我读懂了!”之前，不要说你同意、不同意或暂缓评论。）<br>（10）不要争强好胜，非辩到底不可。<br>（11）在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。<br>B．批评观点的特别标准<br>（12）证明作者的知识不足。<br>（13）证明作者的知识错误。<br>（14）证明作者不合逻辑。<br>（15）证明作者的分析与理由是不完整的。<br>注意：关于最后这四点，前三点是表示不同意见的准则，如果你无法提出相关的佐证，就必须同意作者的说法，或至少一部分说法。你只能因为最后一点理由，对这本书暂缓评论。</p><hr><ol><li>偏见与公正<ol><li>理性化的辩论三条件<ol><li>争辩时要注意你会带进去的情绪。当你情绪很强烈时，你可能会认为自己很有道理</li><li>你要把自己的前提或假设摊出来。</li><li>派别之争几乎难以避免地回造成一些盲点，应尽力尝试不偏不偏不倚</li></ol></li></ol></li></ol><p>作者：这些条件只是理想，仅能做到近似而已</p><ol start="2"><li>可取代三条件的方法<ol><li>你的知识不足</li></ol></li></ol><p>说一位作者知识不足，就是在说他缺少某些与他想要解决的问题相关的知识。注意，除非这些知识确实相关，否则就没有理由作这样的评论。要支持你的论点，你就要能阐述作者所缺乏的知识，并且知识与问题的关系</p><pre><code>  2. 你的知识有错误</code></pre><p>说一位作者的知识错误，就是说他的理念不正确。 这样的错误可能来自缺乏知识，但也可能远不止 于此。不论是哪一种，他的论点就是与事实相反。作者所说的事实或可能的事实，其实都是错的，而且 是不可能的。这样的作者是在主张他自己其实并没有拥有的知识，当然，除非这样的缺点影响到作者的 结论，否则并没必要指出来。要作这个评论，你必须要能说明事实，或是能采取比作者更有可能性的相反立场来支持你的论点。</p><pre><code>  3. 你不合逻辑——你的推论无法令人信服</code></pre><p>即推论荒谬</p><pre><code>     1. 缺乏连贯——结论突然就冒出来了     1. 事件变化的前后不一致——两件事时前后矛盾的  4. 你的分析不够完整——作者没有解决他一开始提出来的所有问题</code></pre><p>该点不得作为不同意作者的根据。然而，当读者找不出任何理由提出其他批评点而同意一本书的部分理论时，或许会因为该点，关于一本书是不完整的论点，而暂缓评论整本书。<br>读者不得随意使用这些评论，除非他确实能够证明。批评一本书的最后阶段，就是要检视作者论述的完整性</p><h3 id="第十二章-辅助阅读"><a href="#第十二章-辅助阅读" class="headerlink" title="第十二章 辅助阅读"></a>第十二章 辅助阅读</h3><p>定义：<br>特殊经验：特殊经常则需要主动地寻找。例如：实验室<br>一般经验：一般经验适用于任何一个活着的人</p><hr><p>主旨：<br>外在阅读的规则：除非你看完了一本书，否则不要看某个人的导读</p><hr><p>如果一直只依靠自己来研究，运用自己的头脑来努力，不用其他帮助。这个可能是错的。有时候非要借助外在阅读，才能完全理解一本书<br>在理解与批评一本书时，内在与外在的阅读通常会混在一起。在诠释、评判和作大纲时，我们都难免受到过去的经验的影响。我们可能不会充分对照其他书籍和自己生活里的经验，但是我们免不了会拿我们的经验去与眼前之物进行对比。这也就是俗话说的，我们不应该，也不可能完全孤立地阅读一本书<br>作者：许多读者太依赖外在读物了。我们建议你在寻找外力帮助之前，最好能自己一个人阅读。如果你经常这么作，最后你会发现越来越不需要外界的助力了</p><ol><li>外在的辅助来源四个部分——1.相关经验、2.其他的书、3.导论与摘要、4.工具书<ol><li>相关经验</li></ol></li></ol><p>要怎样才能知道你是否适当地运用自己的经验，来帮助你读懂一本书呢？ 最确定的测验方式就是我们讨论过的方式，跟测验你的理解力一样，问问你自己：在你觉得自己了解了的某一点上，能不能举出一个实例来？</p><ol start="2"><li>其他的书</li></ol><p>许多伟大的作品不只是互相有关联，而且在写作时还有特定的先后顺序，这都是不该忽略的事。后人的作品总是受到前人的影响。如果你先读前一位的作品，他可能会帮助你了解后人的作品。阅读彼此相关的书籍，依照写作的时间顺序来读，对你了解最后写的作品有很大帮助。这就是外在辅助阅读的基本常识与规则。<br>我们经常会发现，伟大的著作总会有很长的对话部分。伟大的作者也是伟大的读者，想要了解他们，不妨读一读他们在读的书。身为读者，他们也是在与作者对话，就像我们在跟我们所阅读的书进行对话一样。<br>想要加入这样的谈话，我们一定要读与巨著相关的著作，而且要依照写作前后的年表来阅读。有关这些书的对话是有时间顺序的。时间顺序是最基本的，千万不要忽略了。阅读的顺序可以是从现代到过去，也可以从过去到现代。虽然从过去读到现代的作品因为顺其自然而有一定的好处，不过年代的角度也可以倒过来观察。<br>作者：历史和哲学比起科学与小说更需要这样做<br>LZL：用在著作上效果更好</p><ol start="3"><li>如何运用导读和摘要</li></ol><p>要正确地运用这些导读，必须先尽力读完一本书，然后还有些问题在干扰着你时，才能运用这些导读来解答问题<br>摘要绝不能代替真正的阅读，但有时却能告诉你，你想不想或需不需要读这本书</p><pre><code>  1. 如果你已经读过一本书，这些摘要要能唤醒你的记忆。理想上，在分析阅读时，你就该自己作这样的摘要  1. 在主题阅读时，摘要的用处很大，你可以因此知道某些特定的议题时与你的主题密切相关的  1. 一本书的导读并不一定都是对的  1. 就算对了，可能也不完整</code></pre><p>作者：运用这些资料时要特别聪明，也就是要尽量少用</p><ol start="4"><li>如何运用工具书</li></ol><p>在你能运用工具书之前，你自己已经具备了很多知识。工具书对矫正无知是无用的。也不能代替你思考<br>使用工具书之前，你必须有自己的想法：你有什么问题？这个问题要找哪本工具书？<br>在工具书中你只能看到约定俗成的观念，未获得普遍支持的论点不会出现在这种书中</p><pre><code>  1. 最主要的两种工具书     1. 字典        1. 如何使用字典</code></pre><p>字典的基本用途是在你碰到一个专业术语，或者完全不认识的字时，才需要使用上。即便如此，在你第一次阅读一本好书时，也不要着急使用，除非那个字跟主旨有很大的关联<br>字典也可以是一个好玩的读物。在无聊时可以坐下对它进行挑战。毕竟这比其他许多消磨时间的方法高明许多</p><pre><code>        2. 要点——文字是物质的           1. 文字是物质的——可以写成字，也可以说出声音           1. 文字是语言的一部分           1. 文字是符号的</code></pre><p>这些符号是有意义的，不止一种意义，而是很多种意义。这些意义在许多方面是互相</p><pre><code>           4. 文字是约定俗称的</code></pre><p>在中世纪，字典是只属于少数人的读物，主要用作帮助阅读与写作重要的文学作品<br>作者：字典是关于字的一本书，而不是关于事的一本书<br>ME：但是在现在字典也是属于少数人的读物</p><pre><code>     2. 百科全书        1. 如何使用百科全书</code></pre><p>使用百科全书，读者必须要依赖编者的帮忙与建议。任何一本好的百科全书都有引言，指导读者如何有效地运用这本书,，你一定要照着这些指示阅读。<br>一个读者如果不能善用索引，无法让百科全书为己所用，也只能怪他自己了<br>同字典一样，也具备娱乐消遣的价值</p><pre><code>        2. 要点——百科全书是关于事实的           1. 事实是一种说法</code></pre><p>如果你只知道事实本身，表示你了解的并不多</p><pre><code>           2. 事实是一种“真实”的说法</code></pre><p>事实不是观点</p><pre><code>           3. 事实是真相的反映           3. 事实是某种程序上的约定俗成</code></pre><p>作者：事实——在某种程度上——也受到文化的影响<br>作者：虽然不同的字典对文字的说明有同样的看法，但是百科全书对事实的说明却不尽相同。因此，如果你真的对某个主题很感兴趣，而且要靠着百科全书的说明来理解的话,不要只看一本百科全书,要看一种以上的百科全书，选择在不同的时间被写过很多次的解释。</p><h2 id="第三篇-阅读不同读物的方法"><a href="#第三篇-阅读不同读物的方法" class="headerlink" title="第三篇 阅读不同读物的方法"></a>第三篇 阅读不同读物的方法</h2><h3 id="第十三章-如何阅读实用型的书"><a href="#第十三章-如何阅读实用型的书" class="headerlink" title="第十三章 如何阅读实用型的书"></a>第十三章 如何阅读实用型的书</h3><p>你不可能只用一般规则来读任何一本书。在你运用规则时，你一定要有弹性，并能随时调整。幸运的是，当你开始运用这些规则时，你会慢慢感觉到这些规则是如何在不同的读物上发挥作用<br>在这一篇里，比起阅读的规则，我们会更多有关这几个问题的话题。不过大多数时候，既然我们谈的是阅读不同读物的方法,，我们会强调基本要问的不同问题，以及会获得什么样的不同的回答。<br>ME:那么是不是说，对于不同读物，提出不同的问题才是关键的？</p><hr><ol><li>两种实用性的书</li></ol><p>定义：<br>主旨：</p><ol><li>任何实用性的书都不能解决该书所关心的实际问题。一本理论性的作品可以解决自己提出的问题</li><li>理论性的原则可以归纳出出色的行事规则</li></ol><hr><p>实用性作品则没有任何界限，因此我们要进一步分析这类书的特质，并提供一些阅读时的建议指南与方法。<br>读者一定要加上一点自己的想法， 次啊能将实用型的规则运用到实际状况中</p><ol><li>规则型的实用书——烹饪、驾驶指南<ol><li>重点<ol><li>找寻的主旨当然是那些规则——论述通常没阐述原理的书要有说服力，但是能让规则讲的更清晰</li></ol></li></ol></li><li>阐述形成规则的原理的实用书——经济、政治著作<ol><li>重点<ol><li>主旨是在说某件事的状态，而论述就是强调真的是如此——论述没有明说，但是聪明的读者可以看出背后可以衍生出的规则，以及如何实际应用</li></ol></li></ol></li><li>这些是你要了解任何一种实用性书籍，或是在作某种批评时的最高原则。在纯理论性的书中，相同或反对的意见是与书中所谈的真理有关。但是现实的真理与理论的真理不同。行为规则要谈得上是真理，有两种情况：</li></ol><p>一是真的有效;二是这样做能带引你到正确的结果，达到你的期望。<br>区分不是绝对的。一本书可以同时找到原理与规划<br>除非像上两点一样阅读，否则一本实用的书便没有被实用地阅读<br>​</p><p>第一：作者的目的是什么？第二：他建议用什么方法达到这个目的？</p><hr><ol start="2"><li>说服的角色</li></ol><p>每一本实用的书中都混杂着雄辩或宣传。因为你对他作品的评断是来自你是否接受他的结论，与他提议的方法。这完全要看作品能不能将你引导到他的结论上<br>另外还有一个重点。因为实用问题的特性，也因为所有实用作品中都混杂了雄辩，作者的“性格”在实用的书中就比理论书中还要来得重要。</p><hr><ol start="2"><li>赞同实用书之后</li></ol><p>第一个问题：这本书是在谈些什么？<br>第二个问题：为了能回答关于这本书的意义或内容，你仍然要能找出作者的共识、主旨与论述<br>第三个问题：内容真实吗？<br>第四个问题：这本书与我何干？<br>赞同一本实用性的书，需要你采取行动。当然，我们知道这种情形并不一定会发生。那就表示虽然这个读者表面上同意了作者的结论，也接受了他提出来的方法，但是实际上并没有同意，,也没有接受。如果他真的都同意也接受了，他没有理由不采取行动。<br>在这个论述中有一个明显的例外。某些作者提出的结论是很通用或一般性的一可供所有的人类使用一另外一些作者的结论却只有少数人能运用。<br>如果结论是经过筛选的，只适用于某个阶层的人，那么读者便要决定他是否属于那个阶层了。如果他属于那个阶层，这些内容就适合他应用，他多少也有义务照作者的建议采取行动。如果他不属于这个阶层，他可能就没有这样的义务。<br>在许多例子中，我们承认这个结论是可取的，方法也是可行的，但我们却懒得去做。让别人去做。当然，这个问题主要不是阅读的，而是心理的问题。心理问题会影响我们阅读实用性的作品。</p><h3 id="第十四章-如何阅读想象文学"><a href="#第十四章-如何阅读想象文学" class="headerlink" title="第十四章 如何阅读想象文学"></a>第十四章 如何阅读想象文学</h3><hr><p>作者的问题：</p><ol><li>在开始之前，我们要先谈一个有点奇怪的矛盾说法。阅读想象文学的问题比阅读论说性作品的问题更为困难。然而，比起阅读科学、哲学、政治、经济与历史，一般人却似乎更广泛地拥有阅读文学的技巧。为什么会出现这种情况呢？</li></ol><p>ME：关于为什么一个种类的技巧比另一个种类多可以理解，但是为什么说这是奇怪的矛盾？<br>​</p><ol start="2"><li>当我们问到一个人为什么喜欢小说时，他总是表现出瞠目结舌的样子。很明显，他们乐在其中，但是他们说不出来乐在哪里，是哪一部分的内容让他们觉得愉悦。这可能说明了，人们可能是好的小说读者，却不是好的评论者。我们怀疑这只部分的真相。</li></ol><p>​</p><p>人们可能是好的小说读者，却不是好的评论者。我们怀疑这只是部分的真相。评论式的阅读依赖一个人对一本书的全盘了解。这些说不出他们喜欢小说的理由的人，可能只是阅读了表象，而没有深入内里。无论如何，这个矛盾的概念还不止于此。想象文学的主要目的是娱乐，<strong>而非教育</strong>。以娱乐为主的读物比教育为主的读物容易讨好，但要知道为什么能讨好则比较困难。要分析美丽，比美丽本身困难多了。<br>ME：作者需要解释一下娱乐的定义</p><ol start="3"><li>1</li></ol><hr><p><strong>读想象文学的“不要”</strong><br>述说论述性作品与文学作品的差异<br>最明显的差别：论说性作品要传递的是知识——读者曾经经历过或没有过的知识；想象文学是阐述一个经验本身——只有读者借着阅读才能拥有或分享的经验<br>阅读论说性作品，读者应该像个捕食的小鸟，经常保持警觉，随时准备伸出利爪。在阅诗与小说时，相同的活动却有不同的表现方法。如果容许的话，我们可以说那是有点被动的活动，或者，更恰当的法应该是，那是带着活力的热情。在阅读一个故事时，我们一定要用那样的方式来表现，让故事在我们身上活动。们要让故事贯穿我们，做任何它想要做的事。我们一定得打开心灵，接纳它。<br>说主要是运用想象力。这也是为什么称之为想象文学的原因，这与理性的科学或哲学相反。<br>总之，阅读一部伟大的文学作品的规则则应该以达成某种深沉的经验为目标。这些规则应去除我们体验这种深刻感受的阻碍。<br>​</p><p>否认规则：<br>定义：</p><pre><code>  1. 真理：一种写实，一种内在可能性或与真实的神似</code></pre><p>在想象文学中，不要去找共识、主旨或论述。那是逻辑的，不是诗 的，二者完全不同。<br>不要用适用于传递知识的,与真理一致的标准来批评小说。.<br>​</p><p>阅读想象文学的一般规则<br>我们可以将架构性的规则拟大纲的规则改变为适合阅读小说的规则：</p><ol><li>你必须将想象文学作品分类。<ol><li>抒情诗在叙述故事时，基本上是以表达个人情绪的经验为主。</li><li>小说与戏剧的情节比较复杂，牵涉到许多角色，彼此产生互动与反应，以及在过程中情感的变化。<ul><li>戏剧是以行动与说话来叙述剧情的。剧作家不需要自己现身说法</li><li>小说家却经常这么做自己现身说法</li></ul></li></ol></li><li>你要能抓住整本书的大意。我们知道想象文学就是想要传达一个具体的经验，所以一篇故事的大意总是在情节之中。除非你能简要地说明剧情一不是主旨或论述——否则你还是没有抓住重点。在情节中就有大意。</li><li>你不仅要能将整本书简化为大意，还要能发现整本书各个部分是如何架构起来的。一个过程。要了解一个故事的架构，你一定要知道故事是从哪里开始的一一当然，不一定是从第一页开始的一—中间经过些什么事，最后的结局是什么。你要知道带来高潮的各种不同关键是什么，高潮是在哪里、又如何发生的，在这之后的影响又是什么？(我们说“在这之后响”并不是说故事结束之后的事，没有人能知道那些事。我们的意思是在故事中的高潮发生后，带来什么样的后果。)</li></ol><p>优秀的论述性作品每一部分都可以单独阅读，其中的每个部分或章节，分开来看或合起来看都有意义。但是一本小说中的一章，剧本中的幕，或是一句诗从整体中抽出来之后，通常就变得毫无意义了。<br>​</p><p>阅读小说的诠释规则</p><ol><li>小说的要素是插曲、事件、角色与他们的思想、言语、感觉及行动</li><li>一个富有想象力的作者创造出一个世界来，他的角色在其中“生活，行动，有自己的天地。</li><li>你对角色都熟悉了，你加入了这个想象的世界，与他们生活在一起，同意这个社会的法律，呼吸同样的空气，品味同样物，在同样的高速公路上旅行。现在，你一定要跟随他们完成这场探险。</li></ol><p>我们要提醒你，不要太仔细检验这些类似的规则。这些类似的规则就像是一个隐喻或象征，如果压迫得太用力，可能就会崩溃了。<br>​</p><p>一首抒情诗是在呈现一个具体的经验，就像一个长篇故事一样，想要在读者心中重新塑造这种经验<br>​</p><p>小说的批评规则是什么？<br>在你衷心感激作品试着为你创造的经验之前，不要批评一本想象作品<br>你要客观地指出书中某些事件造成你的反感。你不只要能说明你自己为什么喜欢或不喜欢，还要能表达出这本书中哪些地方是好的，哪些是不好的，并说明理由才行。换句话说，对于小说，我们不该反对或赞成，而是喜欢或不喜欢。</p><h3 id="第十五章-阅读故事、戏剧与诗的一些建议"><a href="#第十五章-阅读故事、戏剧与诗的一些建议" class="headerlink" title="第十五章 阅读故事、戏剧与诗的一些建议"></a>第十五章 阅读故事、戏剧与诗的一些建议</h3><p>上一篇的规则运用具体不同的想象文学作品时，需要作一些调整<br>​</p><p>对于阅读想象文学作品，严格来说，在你完成阅读后，是用不着采取什么行动的。但想象文学可以引导出行动，但却并非必要，因为它们属于纯艺术的领域。在故事结束便就不再与其他的影响相关。</p><hr><p>如何阅读故事书<br>快读、全心全意地读。<br>关于名字：在小说中，我们不期望记住每一个名字，许多人不过是背景人物。当我们读完任何一本大部头的书时，我么就知道谁是重要人物，我们也不会忘记。<br>​</p><p>作者的问题：<br>我们所阅读的大部分是故事书，各种各样的故事。不能读书的人，也可以听故事。我们甚至还会自己编故事。对人类而言，小说或虚构的故事似乎是不可或缺的。为什么？<br>其中一个理由是：小说能满足我们潜意识或意识中许多的需要。简单来说-如果要深入讨论这个主题会很复杂，我们喜欢某种人，或讨厌某种人，但却并不很清楚为什么。如果是在小说中，某个人受到奖励或处罚，我们都会有强烈的反应我们会甚至因而对这本书有艺术评价之外的正面或负面的印象。<br>其实，在每个人的面具之下，潜意识里都可能有些虐待狂或被虐狂。这些通常在小说中获得了满足，我们会认同那位征服者或被虐者，或是两者皆可。在这样的状况中，我们只会单地说：我们喜欢“那种小说”——用不着把理由说得太清楚<br>我们并不知道，也不能确定真实的世界是很美好的。但是在伟大的作品中，世界多多少少是美好的。只要有可能，我们希望能经常住在那个故事的世界里。<br>我们可以分享他的洞察力，却不需要分享他的痛苦遭遇。</p><hr><p>关于史诗的重点<br>这是人类最难写的一种作品，但这样的作品并不容易阅读。真正的困难似乎在与如何跟随作品逐步提高那种环绕主题的追寻。<br>​</p><p>如何阅读戏剧<br>一个剧本是一篇小说、故事、同时也真的该像读一个故事一样阅读。<br>有一个重要的差异：你在读剧本时，不是在读一个已经完全完成的作品。阅读剧本所缺乏的就是身体语言实际的演出。读者必须自己提供那样的演出<br>​</p><p>关于悲剧的重点<br>大多数剧本是不值得阅读的。我们认为这是因为剧本并不完整。<br>两点对阅读悲剧有帮助的建议：</p><ol><li>记住悲剧的精髓在时间，或是缺乏时间</li><li>在希腊的戏剧中，所有的悲剧演员都穿一种高出地面几英寸的靴子。叙述旁白不会穿这种靴子。因此，一边是剧的主角，另一边是叙述旁白的演员，两相比较之下，就可以看出极大的差异了。因此你要得，在读旁白的部分时，你要想象这些台词是跟你一般身高的人所说出来的话，而在读悲剧人物台词时，你要想象这是出自一个大人物的口中，他们不只是在形象上，在实际身高上也高出你截。</li></ol><p>​</p><p>如何阅读抒情诗<br>无论我们心中如何激荡着原始的诗情，但是诗仍是由文字组成的，而且 是以条理分明，精巧熟练的方式所组合出来的。<br>​</p><p>规则：</p><ol><li>不论你懂不懂，都要一口气读完，不要停</li><li>重读一遍——大声读出来</li></ol><p>​</p><p>提出的问题：<br>对抒情诗的问题却通常是修辞的问题，或是句法的问题。你无法与诗人达成共识，但是你能找出关键字。你不会从文法中分辨出来，而是从修辞上找到。为什么诗中有些字会跳出来，凝视着你？是因为节奏造成的？还是押的关系？还是这个字一直在重复出现？如果好几段谈的都是同样的概念，那么彼此之间到底什么关联？你找出的答案能帮助你了解这首诗。<br>​</p><h3 id="第十六章-如何阅读历史书"><a href="#第十六章-如何阅读历史书" class="headerlink" title="第十六章 如何阅读历史书"></a>第十六章 如何阅读历史书</h3><p>“历史”就跟“诗”一样，含有多重意义。历史的基本是叙事的，所谓的事指的就是“故事”。<br>​</p><p><strong>难以捉摸的史实</strong><br>历史学家所关心的是已经发生的事件，而且绝大部分是发生在很久以前的事件。所有事件的目击者都死了，他们所提的证据也不是在庭上提出的第一一也就是没有受到严格、仔细的规范。没有人能保证他们真的知道他们在说些什么。一件历史的“事实”虽然我们感觉很相信这两个字代表的意义，但却是世上最难以捉摸的。<br>​</p><p>当然某一种历史事件是可以很确认的。即一件全球性的事件。总不太可能全球的日历都不正确<br>​</p><p><strong>历史的理论</strong><br>如果非要分类不可，我们应该把历史，也就是过去的故事——归类为小说，而非科学<br>​</p><p>当然，一个好的历史学家是不会编造过去的。不过，有一点不能忘记的是，历史学家一定要编纂一些事情。他不是在许多件中找出一个共通的模式，就是要套上一个模式。他一定要假设他知道为什么这些历史上的人会做出这些事。他可能有一套理论或哲学，像是上帝掌管人间的事物一样，编纂出适合他理论的历史。<br>​</p><p>因此如果我们真的想要了解一个事件或时期的历史，就很有必要多看一些相关的论著<br>​</p><p><strong>历史中的普遍性</strong><br>“诗比历史更有哲学性。”。一首好诗不只在当时当地是一首好诗，也在任何时间任何地点都是好诗。这样的诗对所有人类来说都有意义与力量。历史不像诗那样有普遍性。历史与事件有关，诗却不必如此。但是一本的历史书仍然是有普遍性的。<br>​</p><p>阅读历史的要点：</p><ol><li>对你感兴趣的事件或时期，尽可能阅读一种以上的历史书</li><li>阅读历史时，不只要关心在过去某个事件、地点真正发生了什么事，还要读懂在任何时间之中，尤其是现在，人们为什么会有如此这般行动的原因</li></ol><p>​</p><p>阅读历史书要提出的问题<br>尽管历史书更接近小说，而非科学，但仍然能像阅读论说性作品一样来阅读，也应该如此阅读。</p><ol><li>每一本历史书都有一个特殊而且有限定范围的主题</li><li>这个作者是用什么方法来说这个故事的？时期？世代？年代？</li><li>批评历史有两种方式。我们可以批评——但永远要在我们完全了解书中的意义之后——这本历史书不够逼真。</li><li>最后一个问题：这与我何干？</li></ol><p>历史告诉我们人类的过去，也经常引导我们作改变，尝试表现更好的自我。这个问题的答案，就在于实务面，也就是你的政治行为面。<br>​</p><p><strong>如何阅读传记与自传</strong><br>传记是一个真正的故事。这种作品一直以来就是有混合的传统，因此也保持着混杂的特性。<br>​</p><p>要提的问题：</p><ol><li>作者的目的是什么？</li><li>他所谓真实包含哪些条件？</li></ol><p>​</p><p>定案本（一个完结篇的传记，绝不能用来写活着的人）——这样的工作通常是由继承人，或是某个重要人物的朋友来负责的。因为他们的写作态度很小心，因此这个人所犯的错，或是达到的成就都会经过润饰。有时候这也会是好的作品，因为作者的优势–其他作者则不见得一能看到所有相关人士所掌控的资料。<br>​</p><p>授权本传记——通常在告诉我们有关当时的时代背景，人们的生活习惯与态度，以及当大家接受的行为模式——关于不可接受的行为也同时作了点暗示及推论。授权本的传记（几乎所有活着的人的传记属于这一种）还有很多要探索的。<br>​</p><p>一般式传记——介于定案本与授权本之间的传记<br>​</p><p>教诲式传记——含有道德目的的<br>​</p><p>这本书与我何干？传记，就跟历史一样，可能会导引出某个实际的、良心的行动。传记是有启发性的。那是生命的故事，通常是成功者一的故事中可以当作我们生活的指引。<br>​</p><p>如何阅读关于当前的事件<br>分析阅读并不是永远都有必要的。我们所阅读的许多东西都用不上分析阅读的努力跟技巧。<br>​</p><p>在阅读当前事件的报导时，要知道是谁在写这篇报导。这里所说的并不是要认识那位记者，而是要知道他写作的心态是什么。滤镜式的记者有许多种类型，要解记者心中戴着什么样的过滤器，我们一定要提出一连串的问题。这一连串的问题与任何一种导现状的作品都有关。这些问题是：</p><ol><li>这个作者想要证明什么？</li><li>他想要说服谁？——一般人？知道内情的人？会做出反应的人？</li><li>他具有的特殊知识是什么？</li></ol><p>这里所说的“知识”含义很广，说成“观念”或“偏见”可能还更适合一些。许多作者只是为了同意他看法的读者而写书</p><ol start="4"><li>他使用的特殊语言是什么？</li><li>他真的知道自己在说些什么吗？</li></ol><p>就阅读这类书而言，整理一堆“规则”还比不上归纳为一句警告。“读者要擦亮眼睛！”<br>​</p><p>关于文摘的注意事项<br>我们阅读报纸、杂志，甚至广告，主要都是为了获得资讯。这些资料的量太大了，今天已没有人有时间去阅读所有的资讯，顶多阅读一小部分而已。在这类阅读领域中，大众的需激发了许多优秀的新事业的出现。譬如像《时代》（Time）或《新闻周刊》(Newsweek)，这种闻杂志，对大多数人来说就有难以言喻的功能，因为它们能代替我们阅读新闻，还浓缩成包含最本要素的资讯。这些杂志新闻写作者基本上都是读者。他们阅读新闻的方法，则已经远远超越般读者的能力。<br>​</p><p>一般作品，浓缩是可行的，而且通常要比原著还好<br>​</p><p>如果一千页的作品摘成九百页，这样的问题不大。如果一千页的文字浓缩成十页或甚至一页。内容被浓缩越多，我们对浓缩者的特质就更要有所了解。<br>​</p><h3 id="第十七章-如何阅读科学与数学"><a href="#第十七章-如何阅读科学与数学" class="headerlink" title="第十七章 如何阅读科学与数学"></a>第十七章 如何阅读科学与数学</h3><p>我们只限定自己讨论两种形式的书：一种是在我们传统中，伟大的科学与数学的经典之作。另一种则是现代科普著作。<br>原因有两个，第一个很简单，我们没有资格这么做。第二个则是：直到大约 19 世纪末，主要的科学著作都是给门外汉写的。不过大多数现代科学著作并不关心门外汉读者的想法，其至也不想尝试让这样的读者理解——现在所有书籍都呈现这种模式<br>​</p><p>一个一般读者该怎么办？<br>必须退一步，也就是阅读流行的科普书。最重要的还是在阅读好书时达到充分的理解<br>​</p><p>了解科学这一门行业<br>你阅读科学经典著作并不是为了要成为现代专业领域的专家。相反地，你阅读这些书只是为了了解科学的历史与哲学。事实上，这也是一个门外汉对科学应有的责任。只有当你注意到伟大的科学家想要解决的是什么问题时注意到问题的本身及问题的背景-你的责任才算结束<br>重要的是，那是与教育的根本相关的脑力活动，也是从苏格拉底到我们以来，一直被认为是中心的目标，也就是透过怀疑的训练，而释放出一个自由开放的心灵。<br>​</p><p>阅读科学经典名著的建议<br>在科学作品中，主要的词汇通常都是一些不常见的或科技的用语。这些用语很容易找出来，你也可以经由这些用语找到主旨。主旨通常都是很一般性的。科学不是编年史，科学家跟历史学家刚好相反，他们要摆脱时间与地点的限制。他要说的是一般的现象，事物变化的一般规则<br>​</p><p>科学基本上是归纳法，基本论述也就是经由研究查证，建立出来的一个通则。另外一种就是运用演绎法来推论。<br>难点一：为了了解科学中归纳法的论点，你就必须了解科学家引以为理论基础的证据<br>你用不着读完所有的细节才能获得启发。——关于书中的基本构思<br>​</p><p>面对数学的问题<br>符号盲：无法放下对实体的依赖，转而理解在控制之下的符号转换<br>​</p><p>数学其实是一种语言，我们可以像学习自己的语言一样学习他。在学习自己的语言时，我们要学两次：说话、书写。而数学是一种完全的书写语言<br>​</p><p>精确性、逻辑性<br>​</p><p>掌握科学作品中的数学问题</p><ol><li>你至少可以把一些比你想象的基础程度的数学读得更明白</li><li>如果你要读一本书是为了理解数学本身，那么这会比阅读任何其他的书还需要在书页空白处写些笔记。如果只想读一本有数学在内的科学书，跳着略读反而是比较聪明的</li></ol><p>​</p><p>只要你记住，你的责任不是成为这个主题的专家，而是要去了解相关的问题，在阅读时就会轻松许多<br>​</p><p>关于科普书的重点<br>如果你已经具备了一些阅读科学的经典名作的能力，那么这类书籍对你来说就毫无难度了<br>​</p><p>但是这类书籍需要更多专注力，而且还要看作者是否客观。因为这类书籍没有报告、图标、方程式，而且可能信息量密集，你要抓住主旨跟论述<br>​</p><h3 id="第十八章-如何阅读哲学书"><a href="#第十八章-如何阅读哲学书" class="headerlink" title="第十八章 如何阅读哲学书"></a>第十八章 如何阅读哲学书</h3><p>哲学来自怀疑<br>孩子是天生的发问者。并不是他的问题很多，而是那些问题的特质，使他与成人有所区别。成年对好奇心的性质有了转换。他们想要知道事情是否如此，而非为什么如此。<br>跟小孩的好奇心相比，发展出不断追根究底的心态，提出真正有深度的问题，这是另一回事<br>​</p><p>哲学家提出的问题<br>如果思辨或理论型的哲学主要在探讨存在的问题，那就属于形上学。<br>如果问题与变化有关——关于特质与种类的变，变化的条件与原因——就是属于自然哲学<br>如果主要探讨的是知识的问题一一关于我们知，人类知识的起因、范围与限制，确定与不确定的问题——那就属于认识论的部分，也称作知识论。<br>理论与规范哲学的区分而言，如果是关于如何过好生活，个人行为中与恶的标准，这都与伦理学有关，也就是理论哲学的领域<br>如果是关于良好的社会，个人与群之间的行为问题，则是政治学或政治哲学的范畴，也就是规范哲学的领域。<br>​</p><p>现代哲学与传承<br>第一顺位问题：世界上存在及发生了什么事，或人类作该追求的问题<br>第二顺位问题：目前绝大多数哲学家所在的领域。比如：如何用言语表达思想的问题<br>​</p><p>哲学的方法<br>简单来说，哲学就是一种思考，别无他物。回答哲学问题，有严格的检验，以确定答案是否合乎逻辑，但这样检验纯粹是来自一般经验——你身为人就有的经验，而不是哲学家才有的经验。<br>​</p><p>伟大的哲学家——比一般人更深刻地思考这个问题<br>​</p><p>我们还要知道有些问题，并非全部都是真正的哲学问题。例如：古代哲学家经常会问天体与地体<br>​</p><p>整体来说，缺乏科学知识的缺点并不影响到哲学经典作品的本身。要回答哲学的问题，除了思考以外，别无他法。这个领域的特质无法通过望远镜来观察<br>​</p><p>哲学的风格<br>当今最普遍是哲学论文或散文</p><ol><li>哲学对话——例如：柏拉图的《对话录》</li><li>哲学论文或散文</li></ol><p>康德的作品是精致的艺术。他的书中会先谈到主要问题，然后条不紊地从方方面面完整地讨论主题，最后，或是顺便再讨论一些特殊的问题。我们可以从他们的作品中看到学论述的开头、发展与结尾。同时，尤其是在亚里士多德的作品中，我们会看到他提出观点与对立场。因此，从某个角度来看，论文的形式与对话的形式差不多。但是在康德或亚里士多德的品中都不再有戏剧化的表现手法，不再像柏拉图是由立场与观点的冲突来表达论说，而是由哲家直接叙述自己的观点。</p><ol start="3"><li>面对异议</li></ol><p>例：明确指陈各种冲突，将不同观点都说明出来，然后再面对所有不同的意见，提出自己的解决方案</p><ol start="4"><li>哲学系统化</li></ol><p>例：斯宾诺的《伦理学》是运用严格的数学方式来表现的——命题、证明、系理、引理、旁注等等</p><ol start="5"><li>格言形式——《查拉图斯特拉如是说》</li></ol><p>这种不如前几种那么重要<br>用格言的形式来解说哲学，最大的好处在于有启发性。这会给读者一个印象，就像在这些简短的句子中还有言外之意，他必须自己运用思考来理解一一他要能够自己找出各种陈述间的关联，以及不同论辩的立足点。同样地，这样的形式也有很大的缺点，因为这样的形式完没法论说。作者就像个撞了就跑的司机，他碰触到一个主题，谈到有关的真理与洞见，然后就到另一个主题上，却并没有为自己所说的话作适当的辩解。因此，格言的形式对喜欢诗词的人说是很有意思的，但对严肃的哲学家来说却是很头痛的，因为他们希望能跟随着作者的思想，对他作出评论。<br>​</p><p>阅读哲学的提示<br>最重要就是发现问题，或找到书中想要回答的问题。<br>哲学问题是要去解说事物的本质，而不像科学作品要的是描述事物的本质<br>他们表达思想的词句通常来自日常用语，只是用在很特殊的意义上。不能将他们的熟悉的字眼看成一般意义的想法<br>​</p><p>假装相信一些其实你并不相信的事，是很好的心智训练<br>​</p><p>厘清你的思绪<br>一本好的哲学理论的书，就像好的科学论文。你不用担心作者的“问题”，不必对他做过多调查。不过，找一些同样谈过这个话题的作品来读，对你来说很有实际帮助<br>​</p><p>你一定要判断什么成立，什么不成立才行。你把一本哲学书读懂了——也读懂了其他讨论相同主题的书——你就有评论的问题了<br>​</p><p>哲学最大特色就是每个人必须为自己回答这些问题。<br>​</p><p>关于神学的重点</p><ol><li>自然神学</li></ol><p>哲学的一个分支，形而上学的最后一部分。设定某个不因任何事物而发生的原始起因的别称——例如：上帝、奇点。重点在，你要透过不需要外力支援——自然进行的——思考，达成这番认知</p><ol start="2"><li>教义神学</li></ol><p>教义神学的首要原则就是某个宗教的教徒所信奉的经文。如果你没有这样的信仰，也不属于某个教派，想要把教义神学的书读好，你就得拿出读学的精神来读。但是你得永远记住，在有关信仰的文章中，信仰不是一种假设。对有信仰人来说，那是一种确定的知识，而不是一种实验性的观点。<br>​</p><p>如何阅读“经书”<br>这类作品是一本或唯一的一本正确的读物，阅读任何其他的作品都会带来危机，从考试失去高分到灵魂遭谴都有可能。这样的特质是有义务性的。一个忠诚的读者在阅读经书时，有义务要从中找到意义，并能从其他的“事实”中举证其真实性。如果他自己不能这么做，他就有义务去找能做到人。这个人可能是牧师或祭司，或是党派中的上级指导者，或是他的教授。在任何状况中，他都须接受对方提供给他的解决之道。他的阅读基本上是没有自由可言的。相对地，他也会获得阅其他书所没有的一种满足感当作回报。<br>​</p><h3 id="第十九章-如何阅读社会科学"><a href="#第十九章-如何阅读社会科学" class="headerlink" title="第十九章 如何阅读社会科学"></a>第十九章 如何阅读社会科学</h3><p>什么是社会科学？<br>即使不是全部，但大部分有关法律、教育、公共行政的作品，及一部分商业、社会服务的作品，再加上大量的理学作品，也都适合社会科学的定义。<br>​</p><p>阅读社会科学的容易处<br>这类作品通常取材于读者所熟悉的经验——也通常是叙述式的<br>哲学问题所谈论的也是我们一般知道的事情，但是通常我们不会“投入”哲学问题中<br>​</p><p>阅读社会科学的困难处<br>容易之处也是困难之处——你如果跟作者的意见不合，拒绝倾听的话<br>社会科学中的字眼通常是常用字眼，因此我们知道某个文字在这篇文章内的定义是什么——这类定义一般会出现在书的一开头——在开始阅读前，请不要争辩作者的使用规则<br>​</p><p>太多社会科学的作品混杂了科学、哲学与历史等等<br>​</p><p>阅读社会科学作品<br>我们说过很多次“社会科学作品”，却没说过“社会科学书”。这是因为在阅读社会科学时，关于一个主题通常要读好几本书，而不会只读一本书。<br>​</p><h2 id="第四篇-阅读的最终目标"><a href="#第四篇-阅读的最终目标" class="headerlink" title="第四篇 阅读的最终目标"></a>第四篇 阅读的最终目标</h2><h3 id="第二十章-阅读的四个层次：主题阅读"><a href="#第二十章-阅读的四个层次：主题阅读" class="headerlink" title="第二十章 阅读的四个层次：主题阅读"></a>第二十章 阅读的四个层次：主题阅读</h3><p>在作主题阅读时，第一个要求就是知道：对一个特定的问题来说，所牵涉的绝对不是一本书而已。第二个要求则是：要知道总的来说，应该违的是哪此书？第二个要求比第一个要求还难做到。<br>​</p><p>第一个问题：在你决定自己要读写什么之前，你确定要读什么了吗？那跟你的主题有关吗？<br>​</p><p>在主题阅读中，检视阅读所扮演的角色<br>检视阅读是主题阅读时的主要工具或手段了</p><ol><li>他会让你自己想要研究的主题有个清晰的概念</li><li>他会简化你的书目到一个合理的程度</li></ol><p>​</p><p>主题阅读的五个步骤<br>步骤之间是可以互相取代的</p><ol><li>找相关的章节</li></ol><p>要记得你最主要的工作不是理解整本书的内容，而是找出这本书对你的主题有什么帮助。</p><ol start="2"><li>带引作者与你达成共识</li></ol><p>你要由你建立起来的共识去带引作者的话，而不是跟着作者的共识。真正的困难在于要强迫作者使用你的语言</p><ol start="3"><li>厘清问题</li></ol><p>可以先列出一些可以把我们的问题说得比较明白的问题，然后让那些作者来回答这些问题<br>有时候我们必须接受作者可能一个问题也回答不了。在这样的状况中，我们必须要将他视为是对这个问题保持沉默，或尚未作出决定。但有的时候我们可以通过间接的观点找到他的答案</p><ol start="4"><li>界定议题</li></ol><p>如果我们确定各个作者会用不同的方式来回答——赞成 or 反对——那么这个议题就被定义出来了<br>要找出：不同意见彼此的关联，根据作者的观点进行分类</p><ol start="5"><li>分析讨论</li></ol><p>我们必须说明这些问题的不同答案，并说明原因，我们也一定要能够从我们检视过的书中找出支持我们把答案如此分类的根据。只有如此，我们才能说我们真正了解了问题<br>​</p><p>客观的必要性<br>主题阅读的目的，并不是给阅读过程中发展出来的问题提供最终答案，也不是给这个计划开始时候的问题提供最终解答。如果这样做，这只是讨论过程中的另一个声音，失去了疏离和客观性。主题阅读的目的是：“辩证的客观”<br>​</p><p>主题阅读就是要能面面俱到，而自己并不预设立场。有一个好方法，就是读者要不断回头参阅诸多作者的原文，重新再阅读相关章节——确保没有曲解原意。<br>​</p><p>如何应用主题工具书<br>《西方世界的经典名著》——包含了三千种话题或主题，就每一个讨论到的主题，你可以通过索引找出目的地——他不能告诉你这套书里有没有包含其他作品里的什么地方可以找到你要的东西，只有一些粗略的指引<br>​</p><p>主题工具能从三方面帮助刚开始做研究的人：启动阅读、建议阅读、指导阅读<br>启动阅读：主题工具书可以帮读者就他们感兴趣的主题，启动他对一些经典著作的阅读——在这些题上，先阅读来自大量不同作者的一些比较短的章节。这可以帮助我们在读完这些经典著作前，先读进去。<br>​</p><p>建议阅读：在使用主题阅读来阅读经典名著时，再加上主题工具书的帮助。我们很可能开始是对某个话题感兴趣，但后面逐渐对其他的话题感兴趣。然后去研究某位作者，探索上下文<br>​</p><p>指导阅读</p><ol><li>读者阅读的章节所涉及的主题，能够给他一个诠释这些章节的方向</li><li>针对同一个主题，从许多不同的作者与书籍中收集出来的章节，能帮助读者强化对各个章节的诠释能力</li><li>如果主题阅读运用在许多不同的主题上，你会发现同一个章节被主题工具书引述在许多不同主题之下的时候。随着读者针对不同的主要对这些章节进行多少不同的诠释，他会发现这些章节含有丰富的意义。这种多重诠释的技巧不只是阅读技巧中的基本练习，同时也会训练我们的头脑面对任何含义丰富的章节时，能习惯地作出适当的调整。</li></ol><p>​</p><p>​</p><p>我们要指出很重要的一点。主题阅读可以说有两种</p><ol><li>一种是单独使用的主题阅读，一种是与主题工具一起并用</li><li>后一种可以当作是构成前一种阅读计划的分，开始由这里着手，是最聪明的做法。而前一种主题阅读所应用的范围要比后一种广义多。</li></ol><p>​</p><p>构成主题阅读的原则<br>所谓作者本身的词汇是神圣不可侵犯的说法，其实只是再说要将一种说法翻译成另一种说法是非常困难的。这一点我们也同意。但是，困难并非不可能做到<br>​</p><p>主题阅读的精华摘要<br>一是准备阶段，而是主题阅读本身</p><ol><li>观察研究范围：主题阅读的准备阶段<ol><li>针对你要研究的主题，设计一份实验性的书目</li><li>浏览你这份书目上的所有书，确定哪些与你的主题相关，并就你的主题建立起清晰的概念</li></ol></li><li>主题阅读：阅读所有第一阶段收集的书籍<ol><li>浏览在第一阶段被认定与你主题相关的书，找出最相关的章节</li><li>根据主题创造出一套中立的词汇，带引作者达成共识</li><li>建立一个中立的主旨，列出一连串的问题</li><li>界定主要及次要的议题</li><li>分析这些讨论</li></ol></li></ol><p>PS:理想上，要一直保持对话式的疏离与客观。每当你要解读某个作者对一个议题的观点时，必须从他自己的文章中引一段话来并列<br>​</p><h3 id="第二十一章-阅读与心智的成长"><a href="#第二十一章-阅读与心智的成长" class="headerlink" title="第二十一章 阅读与心智的成长"></a>第二十一章 阅读与心智的成长</h3><p>一本好书：一本好书能教你这个世界以及你自己。你不只懂得如何读得更好，还更懂得生命。你变得更有智慧，而不只是更有知识。<br>​</p><p>书的金字塔<br>第一类型：百分之九十九得书籍都对你得阅读技巧毫无帮助<br>第二类型：可以让你学习得书。当你获取主要概念了，你就不再需要再读一遍了，但你可能要常常翻阅，找出一些特定得重点<br>你怎么知道不用再读某一本书了呢？当你的心智反应已经与书中得经验合而为一<br>第三类型：无论你如何读，也不可能尽其究竟。<br>如何分辨？当你把书放回书架上时，你心中会有点疑惑，好像有什么还没弄清楚得事<br>伟大的书可以适应不同层次得需求。</p><p>生命与心智的成长<br>如何找出内在的资源，过更美好的人类生活<br>好的阅读，也就是主动的阅读，不只是对阅读本身有用，也不只是对我们的工作或事业有帮助，更能帮助我们的心智保持活力与成长。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;序言&lt;ol&gt;
&lt;li&gt;说明社会对于阅读书籍的状态。&lt;/li&gt;
&lt;li&gt;介绍阅读的四种层次：&lt;ol&gt;
&lt;li&gt;基础阅读、分析阅读、主题阅读&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;第一篇：阅读的层次&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="如何阅读一本书" scheme="http://liaozonglong.github.io/tags/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    
      <category term="方法论" scheme="http://liaozonglong.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>封装系统</title>
    <link href="http://liaozonglong.github.io/wiki/%E5%B0%81%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    <id>http://liaozonglong.github.io/wiki/封装系统/</id>
    <published>2022-01-10T01:28:54.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<ol><li>定制母盘 （略）</li><li>准备系统封装环境 （略）</li><li>安装母盘</li><li>使用 VM 虚拟机安装母盘系统</li><li>在系统引导安装界面按 Ctrl+shift+f3 进入审核模式</li><li>启用内置 Administrator 账号</li><li>激活系统</li><li>安装运行库</li></ol><hr><ol start="4"><li>系统优化清理</li><li>鱼儿系统工具<ol><li>系统系统</li><li>系统清理</li><li>免疫流氓软件(暂时略过)</li></ol></li><li>Dism++清理<ol><li>空间回收</li></ol></li><li>软媒<ol><li>一键清理</li><li>系统瘦身</li><li>磁盘占用（删除与 WindowsDefender 相关）（暂时略过）</li></ol></li></ol><hr><ol start="5"><li>常用软件安装及设置</li><li>基础软件安装</li><li>激活 office</li><li>拷贝维护工具至 C 盘</li></ol><hr><ol start="6"><li>封装前再次优化清理</li><li>鱼儿系统<ol><li>系统清理</li><li>原创工具-&gt;个性设置与应用关联备份还原-&gt;默认应用关联（系统中，封装前)</li></ol></li><li>关闭磁盘索引</li><li>软媒<ol><li>一键清理</li><li>系统隐私</li></ol></li><li>Dism<ol><li>空间回收</li></ol></li><li>备份系统个性设置（PE 中，封装前）</li></ol><hr><ol start="7"><li>使用 ES5S 进行封装</li><li>制作自解压文件(可略过)<ol><li>制作压缩文件<ol><li>文件参数：<ol><li>压缩格式：7z</li><li>压缩等级：极限压缩</li><li>压缩方法：LZMA</li><li>字典大小：64M</li><li>单词大小：64</li><li>固实数据大小：4GB</li><li>加密算法：AES-256</li><li>更新方式：添加并替换文件</li></ol></li></ol></li><li>压缩文件制作成 exe 自解压文件<ol><li>导入 7z 压缩包</li><li>基本设置<ol><li>解压路径：%HOMEPATH%\Desktop\</li><li>文件覆盖模式：跳过已有文件</li><li>解压后自删除：关闭</li></ol></li></ol></li></ol></li><li>ES5 封装第一阶段设置<ol><li>参数：<ol><li>安全更新：不安装</li><li>右边勾全部打钩</li><li>完成后退出</li></ol></li></ol></li><li>ES5 封装第二阶段 1. 拷文件至 Sysprep 文件夹内 1. 驱动 1. 自解压程序 1. 激活工具 2. ES5 封装第二阶段设置（PE 中） 1. 优化：全选 1. 部署 1. 部署控制：开 1. 万能驱动：关 1. 一键运行库：关 1. 右侧勾选项 1. 自动删除万能驱动解压的驱动文件：开 1. 自动查找并清理可能存在的“AutoRun”病毒：开 3. 系统 1. 系统还原：关闭 1. 系统休眠：打开 1. 电池方案：平衡 1. 变更用户目录：关 1. 转移虚拟内存：关 1. 左下角勾选项 1. 彻底清理系统中残留的驱动信息（慎用）：关 4. 用户 1. 创建新用户：关 1. 启动 admin 账户：开 1. 避免产生 Admin.xxx 用户目录：开 1. 自动登录：关 5. 网络：全关 5. 任务<table><thead><tr><th>部署中</th><th>运行</th><th>%SystemDrive%\Sysprep……(驱动文件)</th></tr></thead><tbody><tr><td>部署中</td><td>运行</td><td>%SystemDrive%\Sysprep……(自解压文件)</td></tr><tr><td>部署后</td><td>运行</td><td>%SystemDrive%\Sysprep…… &#x2F;k19(激活工具-激活 Windows) PS:需要使用静默参数</td></tr><tr><td>部署后</td><td>运行</td><td>%SystemDrive%\Sysprep…… &#x2F;o(激活工具-激活 office) PS:需要使用静默参数</td></tr></tbody></table><pre><code>     7. 其他：全关  3. 注入目标系统的RunOnce.reg注册表文件和内容，目的是让系统进入桌面后执行一次指定路径的批处理文件（略）  3. 还原系统个性设置和默认应用关联</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;定制母盘 （略）&lt;/li&gt;
&lt;li&gt;准备系统封装环境 （略）&lt;/li&gt;
&lt;li&gt;安装母盘&lt;/li&gt;
&lt;li&gt;使用 VM 虚拟机安装母盘系统&lt;/li&gt;
&lt;li&gt;在系统引导安装界面按 Ctrl+shift+f3 进入审核模式&lt;/li&gt;
&lt;li&gt;启用内置 Admini
      
    
    </summary>
    
    
      <category term="系统" scheme="http://liaozonglong.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="封装系统" scheme="http://liaozonglong.github.io/tags/%E5%B0%81%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Windows" scheme="http://liaozonglong.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>散乱</title>
    <link href="http://liaozonglong.github.io/wiki/%E6%95%A3%E4%B9%B1/"/>
    <id>http://liaozonglong.github.io/wiki/散乱/</id>
    <published>2022-01-08T06:53:36.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<ol><li>DDL（数据定义语言）</li></ol><p>DDL 用来创建和修改数据库结构<br>例如：<strong>CREATE DATABASE；CREATE TABLE</strong></p><hr><ol start="2"><li>数据的逻辑独立性是指数据与程序的逻辑独立性。</li></ol><hr><ol start="3"><li>innodb ，是 MySQL 的数据库引擎之一，现为 MySQL 的默认存储引擎 -支持事务处理、支持外键、支持崩溃修复能力和并发控制的存储引擎</li></ol><hr><ol start="4"><li>MySQL 中设置停止二进制文件的操作</li></ol><p>setsql_log_bin&#x3D;0;#设为 0 后，在 Master 数据库上执行的语句都不记录 binlog(二进制日志文件)</p><hr><ol start="5"><li>数据库对象与数据库三级模式对应关系正确的是<blockquote><p>表属于模式、索引属于内模式、视图属于外模式</p></blockquote></li></ol><p>​</p><ol><li><strong>模式（Schema）</strong></li></ol><p>定义：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。<br>理解：<br>① 一个数据库只有一个模式；<br>② 是数据库数据在逻辑级上的视图；<br>③ 数据库模式以某一种数据模型为基础；<br>④ 定义模式时不仅要定义数据的逻辑结构（如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等），而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系。</p><ol start="2"><li><strong>外模式（External Schema）</strong></li></ol><p>定义：也称子模式（Subschema）或用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。<br>理解：<br>① 一个数据库可以有多个外模式；<br>② 外模式就是用户视图；<br>③ 外模式是保证数据安全性的一个有力措施。</p><ol start="3"><li><strong>内模式（Internal Schema）</strong></li></ol><p>定义：也称存储模式（Storage Schema），它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式（例如，记录的存储方式是顺序存储、按照 B 树结构存储还是按 hash 方法存储；索引按照什么方式组织；数据是否压缩存储，是否加密；数据的存储记录结构有何规定）。<br>理解：<br>① 一个数据库只有一个内模式；<br>② 一个表可能由多个文件组成，如：数据文件、索引文件。<br>它是数据库管理系统(DBMS)对数据库中数据进行有效组织和管理的方法<br>其目的有：<br>② 为了减少数据冗余，实现数据共享；<br>② 为了提高存取效率，改善性能。</p><hr><ol start="6"><li>DELETE FROM student<blockquote><p>删除 student 内的数据，不删除表结构</p></blockquote></li></ol><p>删除表 DROP TABLE table_name（包括结构）</p><hr><ol start="7"><li>关系数据库中，主键<blockquote><p>为标识表中唯一的实体</p></blockquote></li></ol><p>​</p><p>关系型数据库中的一条记录中有若干个属性，若其中某一个属性组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键<br>比如 :<br>学生表(学号，姓名，性别，班级)<br>其中每个学生的学号是唯一的，学号就是一个主键<br>成绩表中单一一个属性无法唯一标识一条记录，学号和课程号的组合才可以唯一标识一条记录，所以 学号和课程号的属性组是一个主键</p><p>成绩表中的学号不是成绩表的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的外键</p><p>同理 成绩表中的课程号是课程表的外键</p><p>定义主键和外键主要是为了维护关系数据库的完整性，总结一下： 1.主键是能确定一条记录的唯一标识，比如，一条记录包括身份正号，姓名，年龄。</p><p>身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。 2.外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。</p><p>比如，A 表中的一个字段，是 B 表的主键，那他就可以是 A 表的外键。</p><hr><ol start="8"><li>数据库中缓冲区写入磁盘使用的算法是 LRU</li></ol><p>LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的<a href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/7626091">页面置换算法</a>，选择最近最久未使用的页面予以淘汰。</p><hr><ol start="9"><li>系统故障的恢复操作正确的是<blockquote><p>正向扫描日志文件，对故障发生前已经提交的事务记入重做队列，故障发生时未完成的事务计入撤销队列</p></blockquote></li></ol><hr><ol start="10"><li>InnoDB 引擎使用哪一种算法管理缓冲池<blockquote><p>LRU（最近最少使用）</p></blockquote></li></ol><hr><ol start="11"><li>在 MySQL 数据库中，InnoDB 数据缓冲池用于数据读写描述正确的是<blockquote><p>采用 LRU 算法策略</p></blockquote></li></ol><hr><ol start="12"><li>查询优化策略中，正确的策略是<blockquote><p>尽可能的早做选择和投影（基本思路）</p></blockquote></li></ol><p>​</p><hr><ol start="13"><li>以下不符合数据类型选择总体原则的是<blockquote><p>尽量避免把列设置为 NOT NULL</p></blockquote></li></ol><p>​</p><hr><ol start="14"><li>下列有关中继日志文件介绍错误的是<blockquote><p>中继日志文件拥有与二进制日志文件不同的结构</p></blockquote></li></ol><p>中继日志： 从服务器 I&#x2F;O 线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后从服务器 SQL 线程会读取 relay-log 日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致</p><hr><ol start="15"><li>数据库中数据的物理独立性是指<blockquote><p>用户的应用程序与存储在磁盘上数据库中的数据是相互独立的</p></blockquote></li></ol><p>​</p><hr><ol start="16"><li>MySQL 可视化管理工具 MySQL GUI Tools 中方便数据库迁移的图形化应用程序是 MySQL Migration Toolkit</li></ol><p>MySQL Migration Toolkit(数据迁移工具)</p><hr><ol start="17"><li>显示复制线程状态（分行显示）的命令是（Show slave status\g ）。</li><li>MySQL replication 复制中主机和从机是通过什么进行数据同步的（ Binlog ）</li></ol><p>Binlog （二进制日志文件）</p><hr><ol start="19"><li>索引设计属于数据库设计的（物理设计 ）阶段</li></ol><p>数据库物理设计指的是设计数据库的物理结构，根据数据库的逻辑结构来选定 RDBMS（如 Oracle、Sybase 等），并设计和实施数据库的存储结构、存取方式等。</p><hr><ol start="20"><li>对好的加密算法描述不正确的是<blockquote><p>对授权用户来说，加密模式应依赖于算法的保密</p></blockquote></li></ol><hr><ol start="21"><li>用于控制用户对数据库表建立或删除索引的权限为 index 权限</li></ol><p>INDEX 权限，顾名思义就是在某个表上具有维护索引的权限。</p><hr><ol start="22"><li>MySQL 中，可以用于备份数据库的命令是 mysqldump</li></ol><p>mysqldump 备份数据库</p><hr><ol start="23"><li>关于数据类型的使用建议，以下不正确的是 TIMESTAMP 类型的存储空间少于 DATE 类型</li></ol><p>TIMESTAMP（时间戳）<br>DATE（日期）</p><hr><ol start="24"><li>下列哪个选项可以让从数据库变成其他服务器的主数据库（log_slave_updates）</li></ol><p>master A ——&gt; slave B ——&gt; slave C<br> log_slave_updates 是将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中。<br> 对于 mysql 级联复制，上游的从服务器不仅仅要开启 log_bin 还要开启 log_slave_updates，否则将导致下游的从服务器无法更新复制。</p><hr><ol start="25"><li>数据独立性是核心</li></ol><hr><ol start="26"><li>关于 MySQL 数据库的 MyISAM 存储引擎描述正确的是（B）<blockquote><p>不缓存数据文件，只缓存索引文件</p></blockquote></li></ol><p><strong>MyISAM</strong>是<a href="https://baike.baidu.com/item/MySQL">MySQL</a>的默认<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E">数据库引擎</a>（5.5 版之前），由早期的 ISAM 所改良。虽然性能极佳，但却有一个缺点：不支持<a href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86">事务处理</a>（transaction）。不过，在这几年的发展下，<a href="https://baike.baidu.com/item/MySQL">MySQL</a>也导入了<a href="https://baike.baidu.com/item/InnoDB">InnoDB</a>（另一种数据库引擎），以强化<a href="https://baike.baidu.com/item/%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7">参照完整性</a>与并发违规处理机制，后来就逐渐取代 MyISAM。</p><hr><ol start="27"><li>以下选项中不属于 MySQL 数据库文件的扩展名的是 idb</li></ol><p>idb： 图像数据库是指用来存储各种图像或图形信息及有关文字说明资料的—种数据库。主要应用于建筑、设计、广告、产品目录、图片或照片等资料类型的计算机存储与检索。</p><hr><ol start="28"><li>聚簇索引与非聚簇索引</li></ol><ul><li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li><li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam 通过 key_buffer 把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在 key buffer 命中时，速度慢的原因</li></ul><hr><ol start="29"><li>MySQL 字符集以及校验规则</li><li>字符集(Character set)</li></ol><p>是多个字符(英文字符，汉字字符，或者其他国家语言字符)的集合，字符集种类较多，每个字符集包含的字符个数不同。</p><ol start="2"><li>校对规则 collation 校对</li></ol><p>是在字符集内用于字符比较和排序的一套规则，比如有的规则区分大小写，有的则无视。</p><hr><ol start="30"><li>数据完整性</li></ol><p>数据完整性是为了保证插入到数据库中的数据是正确的,防止用户可能的错误输入。<br>数据完整性分为实<strong>体完整性、域完整性、参照完整性</strong></p><hr><ol start="31"><li>B-树</li></ol><p>在 B-树中查找给定<a href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97/7105697">关键字</a>的方法是，首先把根结点取来，在根结点所包含的关键字 K1,…,Kn 查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在 Ki 与 Ki+1 之间，Pi 为指向子树根节点的指针，此时取<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304">指针</a>Pi 所指的结点继续查找，直至找到，或指针 Pi 为空时查找失败。</p><hr><ol start="32"><li>物理备份和逻辑备份</li></ol><p><strong>物理备份：</strong> 物理备份是磁盘块为基本单位将数据从主机复制到备机。<br><strong>逻辑备份：</strong> 逻辑备份是以文件为基本单位将数据从主机复制到备机。</p><hr><ol start="33"><li>1</li><li>1</li><li>1</li><li>1</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;DDL（数据定义语言）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DDL 用来创建和修改数据库结构&lt;br&gt;例如：&lt;strong&gt;CREATE DATABASE；CREATE TABLE&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;数据的逻辑独立性
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://liaozonglong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="散乱" scheme="http://liaozonglong.github.io/tags/%E6%95%A3%E4%B9%B1/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下建立 Git 与 GitHub 的连接</title>
    <link href="http://liaozonglong.github.io/wiki/Linux%20%E4%B8%8B%E5%BB%BA%E7%AB%8B%20Git%20%E4%B8%8E%20GitHub%20%E7%9A%84%E8%BF%9E%E6%8E%A5/"/>
    <id>http://liaozonglong.github.io/wiki/Linux 下建立 Git 与 GitHub 的连接/</id>
    <published>2022-01-07T01:44:46.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<ol><li>安装 git</li><li>配置 Git 用户信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;woider&quot;</span><br><span class="line">git config --global user.email &quot;woider@gmail.com&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>生成 SSH KEY</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;woider@gmail.com&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>查看 SSH KEY</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~# cd /root/.ssh</span><br><span class="line">root@localhost:~/.ssh# ls -a</span><br></pre></td></tr></table></figure><ol start="5"><li>复制 SSH KEY 至 GitHub</li></ol><p>打开 id_rsa.pub 文件并复制-&gt; 登录 GitHub-&gt;打开 Personal settings 页面-&gt;选择 SSH and GPG keys 选项-&gt;创建并粘贴进去<br>​</p><ol start="6"><li>测试 git 连接</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com                                                    ✔</span><br><span class="line">The authenticity of host &#x27;github.com (20.205.243.166)&#x27; can&#x27;t be established.</span><br><span class="line">This key is not known by any other names</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="line"></span><br><span class="line">出现这个提示输入yes</span><br></pre></td></tr></table></figure><ol><li>安装 hexo</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-cli -g</span><br><span class="line">sudo npm install --save hexo-deployer-git</span><br><span class="line">sudo npm install</span><br></pre></td></tr></table></figure><ol start="2"><li>安装语雀（可选）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -g install yuque-hexo</span><br></pre></td></tr></table></figure><ol start="3"><li>克隆或创建项目</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone repo  #复制远程仓库</span><br><span class="line">git init   #初始化本地仓库</span><br></pre></td></tr></table></figure><ol start="4"><li>上传更改</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .  #增加修改内容</span><br><span class="line">git commit -m &quot;&lt;description&gt;&quot;  #对提交的说明</span><br><span class="line">git push origin master   #上传改动</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;安装 git&lt;/li&gt;
&lt;li&gt;配置 Git 用户信息：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
    
      <category term="linux" scheme="http://liaozonglong.github.io/tags/linux/"/>
    
      <category term="github" scheme="http://liaozonglong.github.io/tags/github/"/>
    
      <category term="git" scheme="http://liaozonglong.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>VIM</title>
    <link href="http://liaozonglong.github.io/wiki/VIM+Markdown/"/>
    <id>http://liaozonglong.github.io/wiki/VIM+Markdown/</id>
    <published>2022-01-06T03:00:36.000Z</published>
    <updated>2022-02-24T08:20:03.219Z</updated>
    
    <content type="html"><![CDATA[<ol><li>安装 vim 的<strong>插件管理器 vundle</strong><br>Vundle 是 Vim 的插件管理器，官方 Github 地址是：<a href="https://link.jianshu.com/?t=https://github.com/VundleVim/Vundle.vim">Vundle</a></li></ol><p>git clone <a href="https://github.com/VundleVim/Vundle.vim.git">https://github.com/VundleVim/Vundle.vim.git</a> ~&#x2F;.vim&#x2F;bundle&#x2F;Vundle.vim</p><ol start="2"><li>编写 vimrc   文件(vundle 配置文件)</li></ol><p>路径：~&#x2F;.vimrc (若无，自行创建)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible    &quot; be iMproved, required</span><br><span class="line">filetype off &quot; required</span><br><span class="line"></span><br><span class="line">&quot; 启用vundle来管理vim插件</span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">&quot; 安装插件写在这之后</span><br><span class="line"></span><br><span class="line">&quot; let Vundle manage Vundle, required</span><br><span class="line">Plugin &#x27;VundleVim/Vundle.vim&#x27;</span><br><span class="line"></span><br><span class="line">&quot; 安装插件写在这之前</span><br><span class="line">call vundle#end() &quot; required</span><br><span class="line">filetype plugin on</span><br><span class="line"></span><br><span class="line">&quot; required&quot; 常用命令</span><br><span class="line">&quot; :PluginList - 查看已经安装的插件</span><br><span class="line">&quot; :PluginInstall - 安装插件</span><br><span class="line">&quot; :PluginUpdate - 更新插件</span><br><span class="line">&quot; :PluginSearch - 搜索插件，例如 :PluginSearch xml就能搜到xml相关的插件</span><br><span class="line">&quot; :PluginClean - 删除插件，把安装插件对应行删除，然后执行这个命令即可</span><br><span class="line"></span><br><span class="line">&quot; h: vundle - 获取帮助</span><br></pre></td></tr></table></figure><p>保存退出，使用 sudo vim。<br>再使用“:PluginInstall”安装插件。出现“done”即安装完成，按 q 退出</p><ol start="3"><li>安装 vim-markdown 插件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">该代码输入至vimrc 文件中的&quot;安装插件写在这之后&quot;和安“装插件写在这之前”之间。并再次运行“:PluginInstall”安装插件</span><br><span class="line">Plugin &#x27;godlygeek/tabular&#x27;</span><br><span class="line">Plugin &#x27;plasticboy/vim-markdown&#x27;</span><br></pre></td></tr></table></figure><ol start="4"><li>安装 node.js</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S yay</span><br><span class="line">yay nodejs-lts   #选择最新的</span><br><span class="line">yay -S npm</span><br></pre></td></tr></table></figure><ol start="5"><li>实时预览插件:vim-instant-markdown</li></ol><p>sudo npm -g install instant-markdown-d</p><ol start="6"><li>添加插件至 vimrc 文件 ，然后保存并安装插件</li></ol><p>Plugin ‘suan&#x2F;vim-instant-markdown’</p><ol start="7"><li>重启之后，编写 md 文件，即自动跳出浏览器实时预览</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;安装 vim 的&lt;strong&gt;插件管理器 vundle&lt;/strong&gt;&lt;br&gt;Vundle 是 Vim 的插件管理器，官方 Github 地址是：&lt;a href=&quot;https://link.jianshu.com/?t=https://github.com/
      
    
    </summary>
    
    
      <category term="计算机" scheme="http://liaozonglong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="计算机语言" scheme="http://liaozonglong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"/>
    
      <category term="VIM" scheme="http://liaozonglong.github.io/tags/VIM/"/>
    
      <category term="Markdown" scheme="http://liaozonglong.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>manjaro</title>
    <link href="http://liaozonglong.github.io/wiki/manjaro/"/>
    <id>http://liaozonglong.github.io/wiki/manjaro/</id>
    <published>2022-01-06T01:23:28.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<p>安装后配置：</p><ol><li>更换国内源：</li></ol><p>sudo pacman-mirrors -c China</p><hr><ol start="2"><li>添加 archlinuxcn 仓库</li></ol><p>定义： Arch Linux 中文社区仓库 是由 Arch Linux 中文社区驱动的非官方用户仓库。包含中文用户常用软件、工具、字体&#x2F;美化包等。<br>​</p><p>命令：sudo vi &#x2F;etc&#x2F;pacman.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在文件下追加</span><br><span class="line">[archlinuxcn]</span><br><span class="line"> SigLevel = Optional TrustedOnly</span><br><span class="line"> Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>参考：</p><hr><ol start="3"><li>更新系统</li></ol><p>sudo pacman -Syyu</p><hr><ol start="4"><li>安装 archlinuxcn-keyring</li></ol><p>定义： 导入 GPG key  。如果不导入安装某些软件可能会导致 gpg 签名错误损坏等<br>sudo pacman -S archlinuxcn-keyring</p><hr><ol start="5"><li>安装中文输入法</li><li>安装 fcitx（ 小企鹅输入法  ）框架，以及可视化设置</li></ol><p>定义： 一个以 GPL 方式发布的输入法框架， 编写它的目是为桌面环境提供一个灵活的输入方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-im #默认全部安装</span><br><span class="line">sudo pacman -S fcitx-configtool</span><br></pre></td></tr></table></figure><ol start="2"><li>安装中文输入法</li></ol><p>sudo pacman -S fcitx-googlepinyin<br>PS: 搜狗拼音在在最新的 manjaro 版本中有很多问题经常崩溃不建议使用，这里推荐使用 fcitx-googlepinyin,你也可以选择 fcitx-sunpinyin<br>​</p><ol start="3"><li>新建~&#x2F;.xprofile 文件，加入如下内容 – 为 fcitx 添加 X 会话的环境变量</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure><hr><ol start="6"><li>更换中文文件夹为英文文件夹</li></ol><p>LC*ALL&#x3D;C xdg-user-dirs-update –force<br>参考：<a href="https://wiki.archlinux.org/title/XDG_user_directories*(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">XDG user directories (简体中文)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装后配置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;更换国内源：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;sudo pacman-mirrors -c China&lt;/p&gt;
&lt;hr&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;添加 archlinuxcn 仓库&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义： Arc
      
    
    </summary>
    
    
      <category term="manjaro" scheme="http://liaozonglong.github.io/tags/manjaro/"/>
    
      <category term="系统" scheme="http://liaozonglong.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>VM安装Manjaro</title>
    <link href="http://liaozonglong.github.io/wiki/VM%E5%AE%89%E8%A3%85Manjaro/"/>
    <id>http://liaozonglong.github.io/wiki/VM安装Manjaro/</id>
    <published>2021-12-30T09:02:18.000Z</published>
    <updated>2022-02-24T08:20:03.149Z</updated>
    
    <content type="html"><![CDATA[<p>​</p><p>虚拟机的版本选其它 Linux5.x 或更高版本内核<br>​</p><p><img src="https://s2.loli.net/2021/12/30/Nqjic4bEUVTwkR9.png#id=ZV6vq&originHeight=353&originWidth=776&originalType=binary%E2%88%B6=1&status=done&style=none#crop=0&crop=0&crop=1&crop=1&id=unyrP&originHeight=353&originWidth=776&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​&lt;/p&gt;
&lt;p&gt;虚拟机的版本选其它 Linux5.x 或更高版本内核&lt;br&gt;​&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2021/12/30/Nqjic4bEUVTwkR9.png#id=ZV6vq&amp;originHeight=353&amp;or
      
    
    </summary>
    
    
      <category term="Manjaro" scheme="http://liaozonglong.github.io/tags/Manjaro/"/>
    
      <category term="VM" scheme="http://liaozonglong.github.io/tags/VM/"/>
    
  </entry>
  
</feed>
