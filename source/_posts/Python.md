---
title: Python
urlname: moyrma
date: '2022-02-07 09:00:25 +0800'
tags:
  - Python
  - 计算机语言
  - 计算机
categories:
  - 计算机
  - 计算机语言
  - Python
---

## 编程之路

计算机科学家像数学家一样，使用规范的语言来阐述思想（尤其是一些计算）；像工程师一样设计、组装系统，并且在多重选择中寻找最优解；像自然科学家一样观察复杂系统的行为模式，建立猜想，测试预估的结果。
唯一最重要的技能就是『解决问题』。解决问题意味着要有能力把问题进行方程化，创造性地考虑解决思路，并且清晰又精确地表达出解决方案

### 程序是什么？

程序是一个指令的序列，来告诉机器如何进行一组运算。这种运算也许是数学上的，比如求解一组等式或者求多项式的根；当然也可以是符号运算，比如在文档中搜索和替换文字，或者一些图形化过程，比如处理图像或者播放一段视频
编程的基础指令：输入系统、输出系统、数学运算、条件判断、重复判断
编程的过程理解成一个把庞大复杂任务进行拆分来解决的过程，分解到适合使用上述的基本指令来解决为止。

### 运算符

"+"、"-"、"\*"、"/"、"%"

### 值和类型

type(需要判断的对象) #判断一个值是什么类型

---

### 公示语言和自然语言

定义：
自然语言：就是人说的语言，比如英语、西班牙语、法语，当然包括中文了。他们往往都不是人主动去设计出来的（当然，人会试图去分析语言的规律），自然而然地发生演进。
公式语言：人们为了特定用途设计出来的。比如数学的符号就是一种公式语言，特别适合表达数字和符号只见的关系。化学家也用元素符号和化学方程式来表示分子的化学结构。

---

语法规则体现在两个方面，代号和结构。
公式语言的语法规则是代号必须有严格的组合结构。
你读一句英语或者公式语言中的语句时候，你必须搞清楚结构（虽然在自然语言中大家
潜意识就能搞定了）。这就叫做解译。
两者的差异：二义性、冗余性、文字修辞
计算机程序的意义必须是无歧义和文采修饰的，能完全用代号和结构的方式进行解析。

---

## 变量，表达式，语句

### 赋值语句

赋值语句的作用是创建一个新的变量，并且赋值给这个变量

### 变量名称

编程的人总得给变量起个有一定意义的名字才能记得住，一般情况就用名字来表示这个变量的用途了
不能用数字来开头。大写字母也能用，不过还是建议都用小写字母来给变量命名，这个比较传统哈
变量名里面可以有下划线\_，一般在多个单词组成的变量名里面往往用到下划线，比如 your_name 等等。

### 表达式和语句

表达式是数值,变量和操作符的组合。单个值本身也被当作一个表达式，变量也是如此
语句是一组具有某些效果的代码，比如创建变量，或者显示值。

### 脚本模式

以上我们一直在用 Python 的交互模式，就是直接咱们人跟解释器来交互。开始学的候这样挺好的，但如果你要想一次运行多行代码，这样就很不方便了。
所以就有另一种选择了，把代码保存成脚本，然后用脚本模式让解释器来运行这些脚本。通常 Python 脚本文件的扩展名是.py
Python 两种模式都支持，所以你可以先用交互模式做点测试，然后再写成脚本。但是两种模式之间有些区别的，所以可能也挺麻烦。

### 运算符优先级

括号>乘方>乘除>加减

### 字符串操作

+：字符串拼接 \*：字符串重复 n 次

### 注释

使用"#"来开头
变量命名得当的话，就没必要用太多注释了，不过名字要是太长了，表达式读起来也挺麻烦，所以就得权衡着来了

### 调试

定义：
前置条件：要在函数开始运行之前就要实现才行
后置条件：后置条件包含函数的预期效果（如画线段）和其他作用

---

语法错误
运行错误：显而易见了，就是直到运行的时候才会出现的错误。这种错误也被叫做异常，因为一般表示一些意外的尤其是比较糟糕的情况发生了
语义错误：这种错误是指你的程序运行没问题，也不产生错误信息，但不能正确工作。程序可能做一些和设计目的不同的事情。
调试也有点像一门实验科学。一旦你有了一个关于所出现的错误的想法，你就修改一下程序再试试看。如果你的假设是正确的，你就能够预料到修改导致的结果，这样在编程的水平上，你就上了一层台阶了，距离让程序工作起来也更近了。
​

前置条件是准备给函数调用者的。如果调用者违背了（妥当标注的）前置条件，然后函数不能正常工作，这个 bug 就会反馈在函数调用者上，而不是函数本身。
如果前置条件得到了满足，而后置条件未能满足，这个 bug 就是函数的了。所以如果你的前后置条件都弄清晰，对调试很有帮助。
​

『对折调试』是一种节省调试时间的方法。比如，如果你的程序有 100 行，你检查一遍就要大概 100 步了。而对折方法就是把程序分成两半。看程序中间位置，或者靠近中间位置的，检查一些中间值。在这些位置添加一些 print 语句（或者其他能够能起到验证效果的东西），然后运行程序

---

## 函数

### 函数调用

一般来说，函数都要“传入”一个参数，“返回”一个结果。结果也被叫做返回值。Python 提供了一些转换数值类型的函数。

### Math functions

Python 内置了一个数学模块，这一模块提供了绝大部分常用的数学函数。模块就是一系列相关函数的集合成的文件。
import math #导入语句

### 组合

一门编程语言最有用的功能莫过于能够用一个个小模块来拼接创作。例如函数的参数可以是任何一种表达式，包括代数运算符：x = math.sin(degrees / 360.0 _ 2 _ math.pi) ß
x = math.exp(math.log(x+1)) #函数的调用本身也可以作为参数
你可以在任何地方放一个值，放任何一个表达式，只有一个例外：一个声明语句的左边
必须是变量名。任何其他的表达式放到等号左边都会导致语法错误（当然也有例外）

### 添加新函数

函数定义要指定这个心函数的名字，还需要一系列语句放到这个函数里面，当调用这个函数的时候，就会运行这些语句了。
​

def 函数名(): <--头部
执行语句... <--函数体
​

如果你在交互模式下面定义函数，解释器会显示三个小点来提醒你定义还没有完成

### 定义并使用

函数名()

### 运行流程

一个 Python 程序都是从第一个语句开始运行的。从首至尾，每次运行一个语句。
函数的定义并不会改变程序的运行流程，但要注意，函数体内部的语句只有在函数被调用的时候才会运行。
总的来说，你阅读一个程序的时候，并不一定总是要从头到尾来读的。有时候你要按照运行流程来读才更好理解。

### 形式参数和实际参数

在函数里面，实际参数会被赋值给形式参数

```python
def print_twice(bruce):
		print(bruce)
		print(bruce)
这个函数把传来的实际参数的值赋给了一个名字叫做burce的形式参数
```

适用于 Python 内置函数的组合规则对自定义的函数也是适用的，所以我们可以把表达式作为实际参数
传递参数的时候用的是实际参数，是把这个实际参数的值交给调用的函数，函数内部接收这个值，可以命名成任意其他名字的形式参数

### 函数内部变量和形参都是局部的

在函数内部建立一个变量，这个变量是仅在函数体内部才存在
形式参数也是局部起作用的。例如在 print_twice 这个函数之外，是不存在 bruce 这个变量的。

### 栈图

要追踪一个变量能在哪些位置使用，咱们就可以画个图表来实现，这种图表叫做栈图。栈图和我们之前提到的状态图有些相似，也会表征每个变量的值，不同的是栈图还会标识出每个变量所属的函数。
每个函数都用一个框架来表示。框架的边上要标明函数的名字，框内填写函数内部的形参和变量。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22295732/1645161244642-4bae0ecd-df05-4786-8e86-b9db1b622eed.png#clientId=u2d41eee7-79ed-4&crop=0&crop=0&crop=1&crop=1&id=WzJm1&name=image.png&originHeight=161&originWidth=308&originalType=binary∶=1&rotation=0&showTitle=false&size=24697&status=done&style=none&taskId=ud398bc96-5bbb-4c1f-b480-8a94125f648&title=)
如果函数调用的时候出错了，Python 会打印出这个出错函数的名字，调用这个出错函数的函数名，以及调用这个调用了出错函数的函数的函数名，一直追溯到主函数
这个一系列的函数列表，就是一个追溯了。这回告诉你哪个程序文件出了错误，哪一行出了错误，以及当时哪些函数在运行。还会告诉你引起错误的代码所在行号。

### 有返回值的函数 和 无返回值的函数

定义：
有返回值的函数：比如数学的函数，都会返回各种结果
无返回值的函数：比如 print_twice，都是进行一些操作，但不返回值

---

如果是脚本模式，你运行一个有返回值的函数，但没有利用这个返回值，这个返回值就会永远丢失了！（译者注：只要有返回值就一定要利用！）

---

### 为什么要用函数？

1. 创建一个新的函数，你就可以把一组语句用一个名字来命名，这样你的程序读起来就清晰多了，后期维护调试也方便
1. 函数的出现能够避免代码冗余，程序内的一些重复的内容就会简化了，变得更小巧。而且在后期进行修改的时候，你只要改函数中的一处地方就可以了，很方便
1. 把长的程序切分成一个个函数，你就可以一步步来 debug 调试，每次只应对一小部分就可以，然后把它们组合起来就可以用了
1. 精细设计的函数会对很多程序都有用处。一旦你写好了并且除了错，这种函数代码可以再利用

## 一个实例

### 开发计划

定义：
泛化：给函数添加参数，就叫做泛化，因为者可以让函数的功能更广泛

---

开发计划是写程序的一系列过程。我们本章所用的就是『封装-泛化』的模式。这一过程的步骤如下：

1. 开始写一个特别小的程序，没有函数定义。
1. 一旦有你的程序能用了，确定一下实现功能的这部分有练习的语句，封装成函数，并命名一下。
1. 通过逐步给这个函数增加参数的方式来泛化。
1. 重复 1-3 步骤，一直到你有了一系列能工作的函数为止。把函数复制粘贴出来，避免重复输入或者修改了。
1. 看看是不是有通过重构来改进函数的可能。比如，假设你在一些地方看到了相似的代码，就可以把这部分代码做成一个函数。

---

### 文档字符串

文档字符串是指：在函数开头部位，解释函数的交互界面的字符串，doc 是文档
documentation 的缩写。下面是一个例子

```python
def polyline(t, n, length, angle):
"""
Draws n line segments with the given length and angle (in degrees) between them.
t is a turtle. """
for i in range(n):
t.fd(length)
t.lt(angle)
```

## 条件循环

### 地板除和求模

floor 除法（地板除法）——运算符"//"：地板除法会把运算结果的小数位舍弃，返回整值
求模——运算符"%"：会把两个数相除然后返回余数。

### 布尔表达式

运算符"=="：一种非对即错的表达式，仅有 true（真）或者 false（假）

### 逻辑运算符

逻辑运算符有三种：且，或以及非
且：比如 x>0 且 x<10
或：
非：非运算，是针对布尔表达式的，非（x>y）为真，那么 x>y 就是假的，意味着 x 小于等于 y。

### 条件执行

if 后面的布尔表达式就叫做条件。如果条件为真，随后缩进的语句就运行。如果条件为假，就不运行
复合语句中语句体内的语句数量是不限制的，但至少要有一个。有的时候会遇到一个语句体内不放语句的情况，比如空出来用来后续补充。这种情况下，你就可以用 pass 语句，就是啥也不会做的。

```python
if x < 0:
	pass
```

### 选择执行

if 语句的第二种形式就是『选择执行』，这种情况下会存在两种备选的语句，根据条件来判断执行哪一个。语法如下所示：

```python
if x % 2 == 0:
    print('x is even')
else:
    print('x is odd')
```

### 链式条件

有时我们要面对的可能性不只有两种，需要更多的分支。这时候可以使用连锁条件来实现：

```python
if x < y:
print('x is less than y')
elif x > y:		#elif是『else if』的缩写
print('x is greater than y')
else:		#else语句必须放到整个条件链；不过else语句并不是必须有的
print('x and y are equal')
```

### 嵌套条件

一个条件判断也可以嵌套在另一个条件判断内

```python
if x == y:
    print('x and y are equal')
else:
    if x < y:
        print('x is less than y')
    else:
        print('x is greater than y')
```

### 递归运算

一个函数可以去调用另一个函数；函数来调用自己也是允许的。这就是递归;执行这种函数的过程就叫递归运算

```python
def countdown(n):
    if n <= 0:
        print('Blastoff!')
    else:
        print(n)
        countdown(n-1)
```

### 递归函数的栈图

每次有一个函数被调用的时候，Python 都会创建一个框架来包含这个函数的局部变量和形式参数。对于递归函数来说，可能会在栈中同时生成多层次的框架。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22295732/1645161244575-33802a22-6390-4b69-b7cb-7ec7a4b98117.png#clientId=u2d41eee7-79ed-4&crop=0&crop=0&crop=1&crop=1&id=pDeKn&name=image.png&originHeight=171&originWidth=154&originalType=binary∶=1&rotation=0&showTitle=false&size=12570&status=done&style=none&taskId=uc1ab1220-8427-4f30-9a1e-7b9cbc8660e&title=)

### 无穷递归

如果一个递归一直都不能到达基准条件，那就会持续不断地进行自我调用，程序也就永远不会终止了。这就叫无穷递归

```python
def recurse():
    recurse()
```

### 键盘输入

内置的一个函数"input"函数这个函数会停止程序运行，等待用户来输入一些内容。用户按下 ESC 或者 Enter 回车键，程序就恢复运行，input 函数就把用户输入的内容作为字符串返回。

```python
name = input('What...is your name?\n')
```

## 有返回值的函数

## 返回值

对函数进行调用，就会产生一个返回的值，我们一般把这个值赋给某个变量，或者放进表达式中来用。

```python
def area(radius):
    a = math.pi * radius**2
    return a
```

有一些临时变量可以让后续的调试过程更简单。所以有时候可以多设置几条返回语句，每一条都对应一种情况

```python
def absolute_value(x):
    if x < 0:
        return -x
    else:
        return x
```

返回语句运行的时候，函数就结束了，也不会运行任何其他的语句了。返回语句后面的代码，执行流程里所有其他的位置都无法再触碰了，这种代码叫做『死亡代码』

### 增量式开发

要应对越来越复杂的程序，你不妨来试试增量式开发的办法。增量式开发的目的是避免长时间的调试过程，一点点对已有的小规模代码进行增补和测试
​

这个函数只需要返回一个值。我们写得这些 print 打印语句都是用来调试的，但一旦程序能正常工作了，就应该把 print 语句去掉。这些 print 代码也叫『脚手架代码』因为是用来构建程序的，但不会被存放在最终版本的程序中
​

这个过程的核心如下：

1. 一定要用一个能工作的程序来开始，每次逐渐添加一些细小增补。在任何时候遇到错误，都应该弄明白错误的位置。
1. 用一些变量来存储中间值，这样你可以显示一下这些值，来检查一下。
1. 程序一旦能工作了，你就应该把一些发挥『脚手架作用』的代码删掉，并且把重复的语句改写成精简版本，但尽量别让程序变得难以阅读。

### 布尔函数

函数也可以返回布尔值，这种情况便于隐藏函数内部的复杂测试。例如：

```python
def is_divisible(x, y):
    if x % y == 0:
        return True
    else:
        return False
```

## 迭代

### 再赋值

对同一个变量可以多次进行赋值。一次新的赋值使得已有的变量获得新的值
对变量进行再赋值总是很有用的，但你用的时候要做好备注和提示。如果变量的值频繁变化，就可能让代码难以阅读和调试

### 更新变量

这种情况下新的值是在旧值基础上进行修改得到的。

```python
x = x + 1
```

### 循环：While 语句

在一个计算机程序里面，重复操作也被叫做迭代。

```python
def countdown(n):
    while n > 0:
        print(n)
        n = n - 1
    print('Blastoff!')
```

### 中断

```python
while True:
    line = input('> ')
    if line == 'done':
        break		#中断语句"break"
        print(line)
    print('Done!')
```

### 平方根

循环经常被用于进行数值运算的程序中，这种程序往往是有一个近似值作为初始值，然后逐渐迭代去改进以接近真实值。
​

通过对比两个数字之间是否相当，可以判断是否接近了真实值。但是这个如果用在浮点型上就会有很大的问题。相比之下，与其对比 x 和 y 是否精确相等，倒不如以下方法更安全：用内置的绝对值函数来计算一下差值的绝对值，也叫做数量级。

```python
if abs(y-x) < epsilon:
    break
```

### 算法

比如找到一个 n 与 9 的成绩，你可以把 n-1 写成第一位，10-n 携程第二位。这个技巧是应对任何个位数字乘以 9 的算式。这就是一个算法了！
执行算法是很无聊的，但设计算法很有趣，是智力上的一种挑战，也是计算机科学的核心部分

## 字符串

一个字符串是一个序列，意味着是对其他值的有序排列

### 字符串是字符

字符串就是一串有序的字符。你可以通过方括号操作符，每次去访问字符串中的一个字
符：

```python
fruit = 'banana'
letter = fruit[0]
```

### len 长度

```python
fruit = 'banana'
len(fruit)
```

### 用 for 循环进行遍历

很多计算过程都需要每次从一个字符串中拿一个字符。一般都是从头开始，依次得到每个字符，然后做点处理，然后一直到末尾。这种处理模式叫遍历。写一个遍历可以使用 while 循环：

```python
index = 0
while index < len(fruit):
    letter = fruit[index]
    print(letter)
    index = index + 1
```

另外一种遍历的方法就是 for 循环了

```python
for letter in fruit:
	print(letter)
```

### 字符串切片

```python
x[n:m]
x[:]		#全部输出
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/22295732/1645161244669-05804564-35a4-4e35-bb55-19960b84a01f.png#clientId=u2d41eee7-79ed-4&crop=0&crop=0&crop=1&crop=1&id=Gkee4&name=image.png&originHeight=61&originWidth=220&originalType=binary∶=1&rotation=0&showTitle=false&size=6883&status=done&style=none&taskId=u9e5e3581-81d8-4277-9c1e-e96ba4b8d37&title=)

### 字符串不可修改

你不能对一个已经存在的字符串进行任何改动。你顶多也就能建立一个新字符串，新字符串可以基于旧字符串进行一些改动。

```python
greeting = 'Hello, world!'
new_greeting = 'J' + greeting[1:]
```

运算符 in
in 这个词在字符串操作中是一个布尔操作符，它读取两个字符串，如果前者的字符串为后者所包含，就返回真，否则为假：

```python
>>>	'a' in 'banana'
True
```

## 列表

Python 里面最有用的一种内置类型：列表。

### 列表即序列

和字符串差不多，列表是一系列的数值的序列。在字符串里面，这些值是字符；在列表里面，这些值可以是任意类型的。一个列表中的值一般叫做列表的元素，有时候也叫列表项。

```python
[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']
```

列表内部可以包含一个列表作为元素

```python
['spam', 2.0, 5, [10, 20]]
```

### 列表元素可修改

```python
cheeses[0]		#方括号内的数字用来确定索引位置
```

修改列表的元素

```python
numbers = [42, 123]
numbers[1] = 5
```

### 遍历一个列表

最常用的办法就是 for 循环了

```python
for cheese in cheeses:
    print(cheese)
```

### 列表运算符

加号+运算符可以把列表拼接在一起：

```python
a = [1, 2, 3]
b = [4, 5, 6]
c = a + b
```

星号\*运算符可以将列表重复指定的次数：

```python
[1, 2, 3] * 3
```

### 列表切片

```python
t = ['a', 'b', 'c', 'd', 'e', 'f']
	t[1:3]
```

### 列表的方法

append 就可以在列表末尾添加一个新的元素：

```python
t = ['a', 'b', 'c']
	t.append('d')
```

extend 使用另一个列表做参数，然后把所有的元素添加到一个列表上。

```python
t1 = ['a', 'b', 'c']
t2 = ['d', 'e']
t1.extend(t2)
```

sort 把列表中的元素从低到高（译者注：下面的例子中是按照 ASCII 码的大小从小到大）排列：

```python
t = ['d', 'c', 'e', 'b', 'a']
t.sort()
```

### 删除元素

从一个列表中删除元素有几种方法。如果你知道你要删除元素的索引，你就可以用 pop 这个方法来实现：

```python
>>> a = [1,2,3]
>>> x = a.pop(1)
>>> a
[1,3]
>>> x
[2]
```

如果你不需要删掉的值了，你可以用 del 运算符来实现：

```python
>>> a = [1,2,3]
>>> del a[1]	#可切片：del a[1:5]
>>> a
[1,3]
```

如果你知道你要删除的元素值，但不知道索引位置，你可以使用 remove 这个方法：

```python
>>> a = [1,2,3]
>>> a.remove(2)
>>> a
[1,3]
```

### 列表和字符串

```python
join：将字符串转换成一个个元素，并转变成列表
>>> a = 'test-and-test'
>>> b = '-'
>>> t = s.split(b)
>>> t
['test','and','test']
```

```python
solit：将列表的元素转变成字符串
>>> a = ['test','and','test']
>>> b = ' '
>>> c = b.join(a)
>>> c
'test and test'
```

### 对象和值

```python
>>> a = 'test'
>>> b = 'test'
>>> a is b
True	#结果为真，即两个变量指向的是同一个对象。如果你创建的是一个列表，那么就是两个对象，结果即False
```

### 别名

```python
>>> a = [1, 2, 3]
>>> b = a
>>> b is a	#修改其中任何一个的值，也会导致另外一个值一起变化
True
```

## 字典

### 字典是一种映射

列表概念的推广。在列表里面，索引必须是整数；而在字典里面，你可以用几乎任何类型来做索引了
​

字典包括一系列的索引，不过就已经不叫索引了，而是叫键，然后还对应着一个个值，就叫键值。每个键对应着各自的一个单独的键值。这种键和键值的对应关系也叫键值对，有时候也叫项
​

```python
test = {one: "test"}	#创建新字典
>>> 'one' in test		#判断该字典是否存在one键
```

### 循环与字典

如果你在 for 语句里面用字典，程序会遍历字典中的所有键。

### 逆向查找

给定一个字典 d，以及一个键 k，很容易找到对应的键值 v=d[k]。这个操作就叫查找。

```python
def reverse_lookup(d, v):
    for k in d:
        if d[k] == v:
            return k
    raise LookupError()
    没有一种简单的语法能实现这样一种逆向查找；你必须搜索一下
```

### 全局变量

在主函数中的变量也叫全局变量，因为所有函数都可以访问这些变量。局部变量在所属的函数结束后就消失了，而主函数在其他函数调用结束后依然还存在
一般常用全局变量作为 flag，也就是标识
​

## 元组

### 元组不可修改

元组是一系列的值。这些值可以是任意类型的，并且用整数序号作为索引，所以可以发现元组和列表非常相似。二者间重要的区别就是元组是不可修改的。

```python
>>> t = ('a', 'b', 'c', 'd', 'e')
#元组的语法是一系列用逗号分隔的值，通常都用一对圆括号把元组的元素包括起来，当然不这样也没事

>>> t1 = 'a',		#要建立一个单个元素构成的元组，必须要在结尾加上逗号

>>> t = ('A',) + t[1:]		#元组是不能修改的，你不能修改其中的元素。但是可以用另一个元组来替换已有的
元组——该语句建立了一个新的元组
```

### 元组赋值

对两个变量的值进行交换是一种常用操作。用常见语句来实现的话，就必须有一个临时变量

```python
>>> temp = a
>>> a = b
>>> b = temp
#上一段语句可以转换成下面条语句
>>> a, b = b, a
```

### 用元组做返回值

严格来说，一个函数只能返回一个值，但如果这个值是一个元组，效果就和返回多个值一样了
将结果存储为一个元组，然后使用元组复制分别调用
​

### 参数长度可变的元组

函数的参数可以有任意多个。用星号\*开头来作为形式参数名，可以将所有实际参数收录到一个元组中。

```python
def printall(*args):
    print(args)

printall(1, 2.0, '3')

(1, 2.0, '3')
```

### 列表和元组

zip 是一个内置函数，接收两个或更多的序列作为参数，然后返回返回一个元组列表，该列表中每个元组都包含了从各个序列中的一个元素。
​

### 词典与元组

字典有一个名为 items 的方法，会返回一个由元组组成的序列，每一个元组都是字典中的一个键值对
​

## 文件

『持久的』程序，就是把数据进行永久存储

### 持久

程序持久的特征：它们运行时间很长（甚至一直在运行）；这些程序还会至少永久保存一部分数据（比如存在硬盘上等等）；然后如果程序关闭了或者重新始了，也能从之前停留的状态继续工作。——例如：操作系统
​

### 读写文件

open 函数会返回一个文件对象，文件对象会提供各种方法来处理文件

```python
#这样用写入的模式来打开，会把旧的文件都清除掉，然后重新写入文件
>>> fout = open('output.txt', 'w')

#write 这个方法就把数据写入到文件中
>>> line1 = "This here's the wattle,\n"
>>> fout.write(line1)
```

### 文件名与路径

文件都是按照目录（也叫文件夹）来组织存放的。每一个运行着的程序都有一个当前目录，也就是用来处理绝大多数运算和操作的默认目录

```python
>>> import os
>>> cwd = os.getcwd()	#获取当前工作目录
```

### 模块

该模块可以把几乎所有类型的对象翻译成字符串模式，以便存储在数据库中，然后用的时候还可以把字符串再翻译回来

```python
>>> import pickle
>>> t = [1, 2, 3]
>>> pickle.dumps(t)
b'\x80\x03]q\x00(K\x01K\x02K\x03e.'
```

### 编写模块

以模块方式导入使用的程序一般用下面这样的惯用形式：

```python
if __name__ == '__main__':
    print(linecount('wc.py'))
```

**name** 是一个内置变量，当程序开始运行的时候被设置。如果程序是作为脚本来运行的，**name** 的值就是'**main**'；这样的话，if 条件满足，测试代码就会运行而如果该代码被用作模块导入了，if 条件不满足，测试的代码就不会运行了
​

## 类和对象

### 用户自定义类型

```python
class Point:
"""Represents a point in 2-D space."""
#头部代码的意思是表示新建的类名字叫 Point。然后类的体内有一个文档字符串，解释类的用途。

>>> Point
<class '__main__.Point'>
#因为 Point 是在顶层位置定义的，所以全名就是__main__.Point

>>> blank = Point()
>>> blank
<__main__.Point object at 0xb7e9d3ac>
#类的对象就像是一个创建对象的工厂。要创建一个 Point，就可以像调用函数一样调用Point。
#创建一个新的对象也叫做实例化，这个对象就是类的一个实例
```

### 属性

```python
blank.x = 3.0		#用点号可以给实例进行赋值——不管该实例内是否存在该变量名的初始化
x = blank.x		#赋值
print(blank.x)		#直接打印
```

一个类去作为另外一个类的属性，就叫做嵌入
​

### 对象可以修改

```python
box.width = box.width + 50
box.height = box.height + 100

你还可以写专门的函数来修改对象
```

### 复制

浅复制：复制一个对象中除了内嵌对象之外的所有引用；通过 copy 模块的 copy 函数来实现。
深复制：复制一个对象的所有内容，包括内嵌对象，以及内嵌对象中的所有内嵌对象等等；通过 copy 模块的 deepcopy 函数来实现。
​

别名有可能让程序读起来有困难，因为在一个位置做出的修改有可能导致另外一个位置发生不可预知的情况。这样也很难去追踪指向一个对象的所有变量
​

copy 模块包含了一个名叫 copy 的函数，可以复制任意对象

```python
>>> p1 = Point()
>>> p1.x = 3.0
>>> p1.y = 4.0
>>> import copy
>>> p2 = copy.copy(p1)

##p1跟p2数据相同，但不是同一个对象
```

## 类和函数

纯函数，这种函数并不修改传来做参数的对象，也没有什么效果，比如显示值啊或者让用户输入啊等等，而只是返回一个值而已。
​

### 原型与规划

原型与补丁模式：一种开发模式，先写一个程序的草稿，然后测试，再改正发现的错误，这样逐步演化的开发模式
这种模式很有效率，尤其是在你对问题的理解不是很深入的时候。不过渐进式的修改也会产生过分复杂的代码——因为要应对很多特例情况，而且也不太靠靠——因为好确定你是否找到了所有的错误。
​

设计规划开发：这种开发模式要求对所面对问题的高程度的深刻理解，相比渐进式开发和原型增补模式要更具有计划性
​

## 类和方法

对象往往代表着现实世界中的事物，方法则相对应地代表着现实世界中事物之间的相互作用

### 面向对象的特性

Python 是一种面向对象的编程语言，这就意味着它提供了一些支持面向对象编程的功能，有以下这些特点：

1. 程序包含类和方法的定义。
1. 大多数运算都以对象运算的形式来实现。

​

### init 方法

在对象被实例化的时候被调用

```python
# inside class Time:
def __init__(self, hour=0, minute=0, second=0):
    self.hour = hour
    self.minute = minute
    self.second = second
```

### str 方法

**str** 是一种特殊的方法，就跟**init**差不多，str 方法是接收一个对象，返回一个代表该对象的字符串

```python
# inside class Time:
def __str__(self):
	return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)
```

写一个新的类的时候，总要先写出来 **init** 方法，这样有利于简化对象的初始化，还要写个 **str** 方法，这个方法在调试的时候很有用
​

### 运算符重载

运算符重载：像+加号这样的运算符，在处理用户自定义类型的时候改变为相应的运算
​

### 接口和实现

面向对象编程设计的目的之一就是让软件更容易维护，这就意味着当系统中其他部分发生改变的时候依然能让程序运行，然后可以修改程序去符合新的需求。
实现这一目标的程序设计原则就是要让接口和实现分开。对于对象来说，这就意着一个类包含的方法要不能被属性表达方式的变化所影响。
